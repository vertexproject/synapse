.. highlight:: none

.. storm-cortex:: default

.. _storm-adv-control:

Storm Reference - Advanced - Control Flow
=========================================

Storm includes a number of common programming control flow structures to facilitate more advanced or complex Storm queries. These include:

- `If-Else Statement`_
- `Switch Statement`_
- `For Loop`_
- `While Loop`_

The examples below are for illustrative purposes. This guide is **not** meant as a Storm programming tutorial, but to introduce Storm users who may not be familiar with programming concepts to possible use cases for these structures.

See also the follwing User Guide and reference sections for additional information:

- :ref:`storm-adv-vars`
- :ref:`storm-adv-methods`
- :ref:`storm-adv-libs`
- :ref:`stormtypes-libs-header`
- :ref:`stormtypes-prim-header`


.. _storm-adv-tips:

Advanced Storm - Tips
---------------------

.. _storm-adv-concepts:

Storm Operating Concepts - Review
+++++++++++++++++++++++++++++++++

.. NOTE::

  It is essential to keep the Storm Operating Concepts in mind when using more advanced Storm queries and constructs. For standard Storm queries, these concepts are intuitive (you don't really need to think about them - Storm "just works"). However, these concepts are critical to writing more complex Storm - remembering these fundamentals can save you time and headaches trying to debug a Storm query that is not behaving the way you think it should.


Users are **strongly encouraged** to review the :ref:`storm-op-concepts` as well as the additional data below.

Recall that:

 - We use the term **working set** to refer to the set of nodes you're operating on in Storm.
 
   - The nodes you "start with" (often by performing an initial lift operation) are your **initial working set**.
   - The nodes at any given point in a Storm query are your **current working set**.
 
 - Storm operations (lifts, filters, pivots, subqueries, commands...) can be **chained** together to form longer, more complex queries. However, each operation is executed **individually** and **in sequence**.
 
 - Each Storm operation typically **changes your current working set**. (We sometimes say that Storm operations **consume** nodes to refer to the fact that in many cases the nodes that "come out" of a Storm operation are not the same nodes that "went in".)
 
   - For example, if you perform a filter operation, the resulting set of nodes is typically a subset of the ones you started with. If you use a pivot operation to navigate from one set of nodes to another, you typically leave your "original" nodes behind and "move to" the new nodes. In most cases, your current working set is consistently changing.
  
 - A Storm query made up of multiple chained operations acts as a **pipeline** through which **each** node passes individually.
   
   - This means that a Storm query is executed once for **each** node that passes through the pipeline - **not** "just once" for the entire set of nodes.
   - The fact that each inbound node is processed independently by each Storm operation impacts your current working set.
   
   A simple example of this is the "duplication" of results (nodes) following some pivot operations - this is expected behavior. If you pivot from a set of FQDNs (``inet:fqdn``) to their DNS A records (``inet:dns:a``) and then to the associated IPv4 addresses (``inet:ipv4``), your results may include multiple instances of the same IPv4 node if more than one FQDN resolved to the same IPv4 address. In short, you get one "copy" of the IPv4 for **each** FQDN that resolved to (had a DNS A record for) that address. (Hence the Storm :ref:`storm-uniq` command to de-duplicate the nodes in the current working set).
   
The way Storm behaves - these operating concepts - impacts advanced constructs such as control flow, and are important to understand when writing and debugging more advanced Storm.


.. _storm-adv-debug:

Storm Debugging Tips
++++++++++++++++++++

This documentation is not meant as a tutorial on advanced Storm, but we can offer a few helpful tips:

 - Be aware of your pipeline - that is, understand what is in your current working set at any point in your query. A significant part of Storm troubleshooting comes down to figuring out that the current working set is not what you think it is.
 - Similarly, because each node passes through each operation in a Storm query individually, each operation (including control flow operations) may execute multiple times. If you don't account for this, it can result in things like:
   
   - An exponentially increasing working set (if each node passing through an operation generates multiple results, and the results are not deduplicated / uniq'ed appropriately).
   - A variable that is set by an operation being consistently changed (re-set) for each node passing through the operation (commonly resulting in "last node wins").
   - A variable that **fails** to be set for a node that does **not** pass through the operation where the variable is assigned (resulting in a ``NoSuchVar`` error).
 
 - It is common to use **subqueries** (see :ref:`storm-ref-subquery`) with advanced Storm to isolate certain operations and keep the "primary" nodes passing through the overall Storm pipeline consistent. This is because unlike most Storm operations and commands, subqueries **do not consume** nodes - by default, what goes into a subquery comes out of a subquery, regardless of what happens inside the subquery itself. There are two common points where subqueries may impact your Storm:
 
   - A set of operations changes your working set, so the node(s) you started with are no longer present (i.e., have been consumed by some operation). In this case you can use a subquery to isolate these operations while keeping your original nodes in the overall pipeline.
   - Operations within a subquery fail to execute. While a subquery can isolate a set of operations, a node still has to pass **into** a subquery for the subquery to execute. A common troubleshooting solution for "why is the code in this subquery not executing?" is that nothing is going "into" the subquery to cause it to run.
 
As with all debugging, ``$lib.print()`` is your friend (see :ref:`stormlibs-lib-print`). Scatter it generously throughout your Storm during testing. You can of course print strings:

::
  
  $lib.print("Hey! This worked!")

...as well as values associated with the node(s) in the current working set, using the various methods associated with the ``$node`` Storm type (see :ref:`storm-adv-methods` for a user-focused introduction to methods, or :ref:`stormtypes-storm-node` in the detailed Storm Libraries / Storm Types documentation):

::
  
  $lib.print($node.ndef())


Control Flow Operations
-----------------------

.. _flow-if-else:

If-Else Statement
+++++++++++++++++

An **if-else statement** matches inbound objects against a specified condition. If that condition is met, a set of Storm operations are performed. If the condition is not met, a different set of Storm operations are performed. Storm supports the use of ``if`` by itself; ``if-else``; or ``if-elif-else``. 

Note that the "Storm operations" performed can include **no** operations / "do nothing" if no Storm is provided (e.g., if the associated curly braces are left empty).

If
**

**Syntax:**

::
  
  if <condition> { <storm> }

If ``<condition>`` is met, execute the Storm query in the curly braces. If ``<condition>`` is not, met do nothing. (Note that this is equivalent to an ``if`` statement followed by an empty ``else`` statement.)


.. NOTE::
  
  If ``<condition>`` is an expression to be evaluated, it must be enclosed in parentheses ``( )``. If the expression includes strings, they must be enclosed in single or double quotes.
  
  ::
    
    if ( $str = 'Oh hai!' ) { <storm> }
  
  Or:
  
  ::
    
    if ( :time > $date ) { <storm> }
  
  (Where ``:time`` represents a property on an inbound node.)


If-Else
*******

**Syntax:**

::
  
  if <condition> { <storm> }
  else { <storm> }

If ``<condition>`` is met, execute the associated Storm; otherwise, execute the alternate Storm.

Similar to the ``if`` example above with no ``else`` option (or an empty query for ``else``), you can have an empty ``if`` query:

::
  
  if <condition> { }
  else { <storm> }

If ``<condition>`` is met, do nothing; otherwise, execute the alternate Storm query.

If-Elif-Else
************

**Syntax:**

::
  
  if <condition> { <storm> }
  elif <condition> { <storm> }
  else { <storm> }

If ``<condition>`` is met, execute the associated Storm; otherwise, if (else if) the second ``<condition>`` is met, execute the associated Storm; otherwise (else) execute the final Storm query.

You can use multiple ``elif`` statements before the final ``else``. ``If-elif-else`` is helpful because it allows you to handle multiple conditions differently while avoiding "nested" ``if-else`` statements (which may be appropriate in some cases, but overly complex and unnecessary in others).


**Example:**

You have a subscription to a third-party malware service that allows you to download malware binaries via the service's API. However, the service has a query limit, so you don't want to make any unnecessary API requests that might exhaust your limit.

You can use a simple if-else statement to check whether you already have a copy of the binary in your storage Axon before attempting to download it.

.. storm-pre:: $pkg=$lib.dict(name='docs', version='0.0.1', commands=($lib.dict(name=malware.download, storm=${} ),)) $lib.print($pkg) $lib.pkg.add($pkg) [file:bytes=e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855]
.. storm-multiline:: ENRICH="file:bytes=e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n  $sha256 = :sha256\n  \n  if $lib.bytes.has($sha256) { }\n  \n  else { | malware.download }\n"
.. storm-cli:: MULTILINE=ENRICH   

The Storm query above:

- takes an inbound ``file:bytes`` node;
- sets the variable ``$sha256`` to the file's SHA256 hash;
- checks for the file in the Axon (:ref:`stormlibs-lib-bytes-has`);
- if ``$lib.bytes.has($sha256)`` returns ``true`` (i.e., we have the file), do nothing (``{  }``);
- otherwise call the ``malware.download`` service to attempt to download the file.

**Note:** ``malware.download`` is used as an example Storm service name only, it does not exist in the base Synapse code.

.. _flow-switch:

Switch Statement
++++++++++++++++

A **switch statement** matches inbound objects against a set of specified constants. Depending on which constant is matched, a set of Storm operations is performed. The switch statement can include an optional **default case** to perform a set of Storm operations in the case where none of the explicitly defined constants are matched.

**Syntax:**

:: 
  
  <inbound nodes>
  
  switch <constant> {
    
    <case1>: { <storm> }
    <case2>: { <storm> }
    <case3>: { <storm> }
    *: { <storm for optional default case> }
  }


**Example:**

You want to write a macro (see :ref:`auto-macros`) to automatically enrich a set of indicators (i.e., query third-party data sources for additional data). Instead of writing separate macros for each type of indicator, you want a single macro that can take any type of indicator and send it to the appropriate Storm services.

A switch statement can send your indicators to the correct services based on the kind of node (e.g., the node's form).

:: 

  <inbound nodes>
  
  switch $node.form() {
  
      "hash:md5": { | malware.service }
      
      "hash:sha1": { | malware.service }
      
      "hash:sha256": { | malware.service }
      
      "inet:fqdn": { | pdns.service | whois.service }
      
      "inet:ipv4": { | pdns.service }
      
      "inet:email": { | whois.service }
      
      *: { $lib.print("{form} is not supported.", form=$node.form()) }
  }

The Storm query above:

- takes a set of inbound nodes;
- checks the switch conditions based on the form of the node (see :ref:`meth-node-form`);
- matches the form name against the list of forms;
- handles each form differently (e.g., hashes are submitted to a malware service, domains are submitted to passive DNS and whois services, etc.)
- if the inbound form does not match any of the specified cases, print (:ref:`stormlibs-lib-print`) the specified statement (e.g., ``"file:bytes is not supported."``).

The default case above is not strictly necessary - any inbound nodes that fail to match a condition will simply pass through the switch statement with no action taken. It is used above to illustrate the use of a default case for any non-matching nodes.

**Note:** the Storm service names used above are examples only. Services with those names do not exist in the base Synapse code.  

.. _flow-for:


For Loop
++++++++

A **for loop** will iterate over a set of objects, performing the specified Storm operations on each object in the set.

**Syntax:**

:: 

  for $<var> in $<vars> {
  
      <storm>
  }

**Note:** The user documentation for the Synapse csvtool (:ref:`syn-tools-csvtool`) includes additional examples of using a for loop to iterate over the rows of a CSV-formatted file (i.e., ``for $row in $rows { <storm> }``).

**Example:**

You are writing a "threat hunting" macro (see :ref:`auto-macros`) that:

- lifts FQDN nodes associated with various threat clusters (e.g., tagged ``threat.<cluster_name>``);
- pivots to DNS request nodes (``inet:dns:request``) that:

  - query the FQDN (``:query:name:fqdn``), and
  - have an associated file (``:exe``) (that is, the DNS query was made by a file)

- pivots to the file node(s) (``file:bytes``)
- tags the file(s) for review to see if they should be added to the threat cluster.

This may help to identify previously unknown binaries that query for known malicious FQDNs.

The macro can be run periodically to search for new threat indicators, based on nodes that may have been recently added to the Cortex.

Because your macro may flag a large number of files associated with a broad range of threat clusters, you want your ``#review`` tag to include the name of the potentially associated threat cluster to help with the review process.

You can use a for loop to iterate over the threat cluster tags on the inbound nodes and parse those tags to create equivalent review tags for each threat cluster.

.. storm-pre:: [inet:fqdn=realbad.com +#threat.viciouswombat]
.. storm-multiline:: ENRICH="inet:fqdn=realbad.com\n\n  for $tag in $node.tags(threat.*) {\n  \n     $threat = $tag.split(\".\").index(1)\n     $reviewtag = $lib.str.format(\"review.{threat}\", threat=$threat)\n     $lib.print($reviewtag) \n }\n"
.. storm-cli:: MULTILINE=ENRICH

For each inbound node, the for loop:

- takes each tag on the inbound node (see :ref:`meth-node-tags`) that matches the specified pattern (``threat.*``);
- splits the tag along the dot (``.``) separator (:ref:`stormprims-Str-split`), creating a list of elements;
- takes the element located at index 1 (i.e., the second element in the tag, since we count from zero) (:ref:`stormprims-list-index`) and assigns it to the variable ``$threat``;
- formats a string representing the new "review" tag, using the value of the ``$threat`` variable (:ref:`stormlibs-lib-str-format`).

In other words, if an inbound node has the tag ``#threat.viciouswombat``, the for loop will:

- split the tag into elements ``threat`` and ``viciouswombat``;
- take the element at index 1 (``viciouswombat``);
- set ``$threat = viciouswombat``
- set ``$reviewtag = review.viciouswombat``.



The for loop can be incorporated into your larger "threat hunting" macro to identify files that query for known malicious FQDNs:

.. storm-pre:: [inet:fqdn=www.applenetting.com +#threat.viciouswombat +#threat.spuriousunicorn] | spin | [inet:dns:request="*" :exe=sha256:918de40e8ba7e9c1ba555aa22c8acbfdf77f9c050d5ddcd7bd0e3221195c876f :query:name:fqdn=www.applenetting.com]
.. storm-multiline:: ENRICH="inet:fqdn#threat\n  \n  for $tag in $node.tags(threat.*) {\n  \n      $threat = $tag.split(\".\").index(1)\n      $reviewtag = $lib.str.format(\"review.{threat}\", threat=$threat)\n  }\n  \n  -> inet:dns:request +:exe -> file:bytes [ +#$reviewtag ]\n"
.. storm-cli:: MULTILINE=ENRICH

.. NOTE::
  
  A for loop will iterate over "all the things" as defined by the for loop syntax. In the example above, a single inbound node may have multiple tags that match the pattern defined by the for loop. This means that the for loop operations will execute once **per matching tag per node** and yield the inbound node to the pipeline for each iteration. In other words, for **each** inbound node:
  
    - the first matching tag enters the for loop;
    - the loop operations are performed on that tag (i.e., the tag is split and an associated ``#review`` tag constructed);
    - the variable ``$reviewtag``, which contains the newly-constructed tag, exits the for loop;
    - the FQDN **node** that was inbound to the for loop is subject to the post-loop pivot and filter operations;
    - if the operations are successful, the appropriate ``$reviewtag`` is applied to the node.
    - If there are additional tags to process from the inbound node, **repeat these steps for each tag.**
  
  This means that if a single inbound FQDN node has the tags ``#threat.viciouswombat`` and ``#threat.spuriousunicorn``, a ``file:bytes`` node that queries the FQDN will receive both ``#review.viciouswombat`` and ``#review.spuriousunicorn``.
  
  This is by design, and is the way Storm variables - specifically non-runtime safe variables (:ref:`gloss-non-runtsafe`) - and the Storm execution pipeline (see :ref:`storm-op-concepts`) are intended to work. (Of course, if your analysis has attributed a single FQDN to two different threat groups, you'd want to know about it.)


.. _flow-while:

While Loop
++++++++++

A **while loop** checks inbound nodes against a specified condition and performs the specified Storm operations for as long as the condition is met.

**Syntax:**

:: 

  while <condition> {
  
      <storm>
  }

While loops are more frequently used for developer tasks, such as consuming from Queues; and are less common for day-to-day user use cases.
