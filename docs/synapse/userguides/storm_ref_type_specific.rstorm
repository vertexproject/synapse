.. highlight:: none

.. storm-cortex:: default

.. _storm-ref-type-specific:

Storm Reference - Type-Specific Storm Behavior
==============================================

Some data `types`_ within Synapse have additional optimizations. These include optimizations for:

- indexing (how the type is stored for retrieval);
- parsing (how the type can be specified for input);
- insertion (how the type can be used to create or modify nodes);
- operations (how the type can be lifted, filtered, or otherwise compared).

Types that have been optimized in various ways are documented below along with any specialized operations that
may be available for those types.

This section is **not** a complete reference of all available types. In addition, this section does **not**
address the full range of type enforcement constraints that may restrict the values that can be specified for
a given type (such as via a constructor (``ctor``)). For details on available types and type constraints or
enforcement, see the online documentation_ or the Synapse source code_.

- `array`_ (array)
- `duration`_ (duration)
- `file:bytes`_ (file)
- `guid`_ (globally unique identifier)
- `inet:fqdn`_ (FQDN)
- `inet:ipv4`_ (IPv4)
- `int`_ (integer)
- `ival`_ (time interval)
- `loc`_ (location)
- `str`_ (string)
- `syn:tag`_ (tag)
- `taxonomy`_ (taxonomy)
- `time`_ (date/time)

.. _type-array:

array
-----

An ``array`` is a specialized type that consists of either a list or a set of typed values. That is, an array
is a type that consists of one or more values that are themselves all of a single, defined type.

.. TIP::
  
  An array that is a **list** can have duplicate entries in the list.
  An array that is a **set** consists of a unique group of entries.

``Array`` types can be used for secondary properties where that property is likely to have multiple values.
Examples of array secondary properties include ``media:news:authors``, ``inet:email:message:headers``, and
``ps:person:names``. You can view all secondary properties that are ``array`` types using the following Storm
query:

::
  
  syn:prop:type=array

.. TIP::
  
  Some forms include both a singular and an array property for the same type. This allows you to record a
  primary value along with optional variations (e.g., such as ``ou:org:name`` and ``ou:org:names``),
  or a primary and optional secondary values (e.g., such as  ``ou:campaign:goal`` and ``ou:campaign:goals``).

Indexing
++++++++

N/A

Parsing
+++++++

Because an ``array`` is a list or set of typed values, ``array`` elements can be input in any format supported
by the type of the elements themselves. For example, if an ``array`` consists of ``inet:ipv4`` values, the
values can be input in any supported ``inet:ipv4`` format (e.g., integer, hex, dotted-decimal string, etc.).

Insertion
+++++++++

Because an array may contain multiple values, an ``array`` property must be set using comma-separated values enclosed
in parentheses (this is true even if the array contains only a single element; you must still use parentheses,
and the single element must still be followed by a trailing comma). Single or double quotes are required in
accordance with the standard rules for using :ref:`storm-whitespace-literals`.

**Example:**

Set the ``:names`` property of an organization (``ou:org``) node to a single value:

.. storm-pre:: [ ou:org=('the vertex project',) :name=vertex :url=https://vertex.link/ ]
.. storm-cli:: ou:org:name=vertex [ :names=('The Vertex Project',) ]

**Example:**

Set the ``:names`` property of an organization (``ou:org``) node to contain multiple variations of the
organization name:

.. storm-cli:: ou:org:name=vertex [ :names=('The Vertex Project', 'The Vertex Project, LLC', Vertex) ]

.. WARNING::
  
  Using the equals ( ``=`` ) operator to set an array property value will set or update (overwrite) the
  **entire** property value. To add or remove individual elements from an array, use the ``+=``, ``-=``,
  ``++=``, or ``--=`` operators.

**Example:**

Add a name to the array of names associated with an organization:

.. storm-pre:: [ ou:org=* :name='Monty Python' ] 
.. storm-cli:: ou:org:name='Monty Python' [ :names+='The Spanish Inquisition' ]

Remove a name from the array of names associated with an organization:

.. storm-cli:: ou:org:name='Monty Python' [ :names-='The Spanish Inquisition' ]

Add multiple values to the array of names associated with an organization:

.. storm-cli:: ou:org:name='Monty Python' [ :names ++= ('The Spanish Inquisition', "Monty Python's Flying Circus") ]

Remove multiple values from the array of names associated with an organization:

.. storm-cli:: ou:org:name=vertex [ :names --= ('The Spanish Inquisition', "Monty Python's Flying Circus") ]

.. TIP::
  
  The standard "edit try" operator ( ``?=`` ) (see :ref:`edit-try` in the :ref:`storm-ref-data-mod`) can
  be used to attempt to set a **full** array property value where you are unsure whether the value will
  succeed. The specialized ``?+=`` or ``?-=`` operators can be used to attempt to add or remove a **single**
  array value in a similar manner. The ``?++=`` and ``?--=`` operators can be used to attempt to add or remove
  multiple values from an array value, ignoring any items which fail to normalize.

**Example:**

Use the specialized "edit try" operator to attempt to add a single value to the ``:authors`` array property
of an article (``media:news`` node). (**Note:** a type-inappropriate value (a name) is used below to show
the "fail silently" behavior for the "edit try" operator. The ``:authors`` property is an array of
``ps:contact`` nodes and requires ``ps:contact`` guid values.)


.. storm-pre:: [ media:news="*" :publisher:name=kaspersky :title='New report on really bad threat' ]
.. storm-cli:: media:news:publisher:name=kaspersky [ :authors?+='john smith' ]


**Usage Notes:**

- When using the standard "edit try" operator ( ``?=`` ) to attempt to set the **full** value of an array
  property (vs. adding or removing an element from an array), the **entire** attempt will fail if **any** value
  in the list of values fails. For example, if you try to set ``[ :identities:emails?=(alice@vertex.link, bob) ]``
  on an X509 certificate (``crypto:x509:cert``), Synapse will fail to set the property altogether because ``bob``
  is not a valid email address type (even though ``alice@vertex.link`` is).

- The "edit try" operators for **removing** elements from an array ( ``?-=`` or ``?--=`` ) are unique to arrays
  as they are the only type that allows removal of a individual elements from a property. (Properties with a single
  value are either set, modified (updated), or the property is deleted altogether.) As with other uses of 
  "edit try", use of the operator allows the operation to silently fail (vs. error and halt) if the operation
  attempts to remove a value from an array that does not match the array's defined type. For example, attempting
  to remove an IPv4 from an array of email addresses will halt with a ``BadTypeValu`` error if the standard 
  remove operator ( ``-=``) is used, but silently fail (do nothing and continue) if the "edit try" version
  ( ``?-=``) is used.

Operations
++++++++++

Lifting and Filtering
~~~~~~~~~~~~~~~~~~~~~

Lifting or filtering array properties using the equals ( ``=`` ) operator requires an **exact match** of the
full array property value. This makes sense for forms with simple values like ``inet:ipv4=1.2.3.4``, but is
often infeasible for arrays because lifting by the **full** array value requires you to know the **exact**
values of each of the array elements as well as their **exact** order:

.. storm-cli:: ou:org:names=("The Vertex Project", "The Vertex Project, LLC", Vertex)

For this reason, Storm offers a special "by" syntax for lifting and filtering with ``array`` types. The syntax
consists of an asterisk ( ``*`` ) preceding a set of square brackets ( ``[ ]`` ), where the square brackets
contain a comparison operator and a value that can match one or more elements in the array. This allows users
to match one or more elements in the array similarly to how they would match individual property values.

.. NOTE::
  The square brackets used to lift or filter based on values in an array should not be confused with square
  brackets used to add or modify nodes or properties in :ref:`edit-mode`.

**Examples:**

Lift the ``ou:org`` node(s) whose ``:names`` property contains a name that exactly matches ``vertex``:

.. storm-cli:: ou:org:names*[=vertex]

Lift the ``ou:org`` node(s) whose ``:names`` property contains a name that includes the string ``vertex``:

.. storm-cli:: ou:org:names*[~=vertex]

**Note:** the above query returns three "copies" of the ``ou:org`` node because each of the three values in
the ``:names`` array matches the queried string.

Lift the x509 certificate nodes that reference the domain ``microsoft.com``:

.. storm-pre:: [crypto:x509:cert="*" :identities:fqdns=(microsoft.com,verisign.com)] 
.. storm-cli:: crypto:x509:cert:identities:fqdns*[=microsoft.com]

Filter a set of ``ou:org`` nodes to include only those with a name that starts with "acme":

.. storm-pre:: [ ( ou:org="*" :name='acme consulting' :names=('acme consulting',) ) ( ou:org="*" :name='acme construction' :names=('acme construction',) ) ]
.. storm-cli:: ou:org +:names*[^=acme]

See :ref:`lift-by-arrays` and :ref:`filter-by-arrays` for additional details.

Pivoting
~~~~~~~~

Synapse and Storm are type-aware and will facilitate pivoting between properties of the same type. This
includes pivoting between individual typed properties and array properties consisting of those same types.
Type awareness for arrays includes both standard form and property pivots as well as wildcard pivots.

**Examples:**

Pivot from a set of x509 certificate nodes to the set of domains referenced by the certificates (such as in
the ``:identities:fqdns`` array property):


.. storm-cli:: crypto:x509:cert -> inet:fqdn


Pivot from a set of ``ou:name`` nodes to any nodes that reference those names (this would include ``ou:org``
nodes where the ``ou:name`` is present in the ``:name`` property or as an element in the ``:names`` array):


.. storm-cli:: ou:name^=acme <- *


.. _type-duration:

duration
--------

``duration`` is a type that represents a period (length) of time.

Indexing
++++++++

A ``duration`` is stored as an integer value representing the number of milliseconds.

Parsing
+++++++

A ``duration`` is commonly specified using a string value (days / hours / minutes / seconds / milliseconds
as appropriate) with the following notation:
  
  ``##D hh:mm:ss.mmm``

The literal uppercase letter "D" is used to represent the number of days. When entering a duration value as a
string, single or double quotes are required in accordance with the standard rules for using
:ref:`storm-whitespace-literals`.
  
A ``duration`` can also be specified as the number of milliseconds expressed as an integer value
enclosed in parentheses:
  
  ``(218262777)``

.. TIP::
  
  Similar to :ref:`type-time` types, Synapse expects that users will generally enter duration values using
  "human friendly" strings, and will attempt to parse the input as such. Using parentheses tells Synapse
  to interpret the value as a raw integer.
  
  Note that this parentheses syntax only applies when setting or updating a ``duration`` property using
  Storm. When setting or updating a property in the `Optic UI`_ by editing a field, you must enter a
  duration string value.


Insertion
+++++++++

When setting a ``duration`` value, enter the value using either format above.

**Examples:**

Set the duration of a compromise (``risk:compromise`` node) to six days, six hours, 46 minutes, and
23 seconds:

.. storm-cli:: [ risk:compromise = * :name = 'example compromise' :duration = '6D 06:46:23' ]

Or:

.. storm-cli:: [ risk:compromise = * :name = 'example compromise' :duration = (542783000) ]

Values can be set at any level of granularity; e.g., ``[ :duration = 19D ]`` is acceptable, as are
values to millisecond resolution.

.. NOTE::

  Forms that have ``duration`` properties may have related :ref:`type-time` properties as appropriate
  for the form, such as a start time or end time or both. A compromise (``risk:compromise`` node) is
  one example and includes start time (``:time``), end time (``:lasttime``), and duration (``:duration``).
  This allows you to set any or all properties, depending on the information available. For example,
  you may know when a compromise was fully remediated (ended), but not when it began or how long it lasted.
  
  While start, end, and duration values are related, Synapse does **not** currently calculate values
  for these properties. That is, entering a start time and a duration will not automatically calculate
  and set the ending time. Similarly, if all three values are set and you modify one of the values,
  the other value(s) are not updated to reflect the change (e.g., changing the duration will not
  automatically update the ending time).
  
  That said, in cases where a node has start, end, and duration properties and you have two of the
  three values, you can use variables_ to calculate and set the third value. For example, given a
  ``risk:compromise:name = 'my compromise'``  with ``:time = '2023/09/22 10:40'`` and
  ``:lasttime = '2023/10/06 14:00'`` you could set the ``:duration`` value using the following Storm query:
  
  ``risk:compromise:name='my compromise' $min=:time $max=:lasttime [ :duration=( $max - $min ) ]``
  
  This will set ``:duration = 14D 03:20:00.000``.


Operations
++++++++++

As ``duration`` types are stored as integers, they support any operations suitable for integer values.
This includes:

- comparison using mathematical operators (such as greater than ( ``>``));
- finding low or high values using the :ref:`storm-min` or :ref:`storm-max` commands;
- use of the range ( ``*range=`` ) comparison operator;

...etc.


.. _type-file:

file\:bytes
-----------

``file:bytes`` is a special type used to represent any file (i.e., any arbitrary set of bytes). Note that a
file can be represented as a node within a Cortex regardless of whether the file itself (the specific set of
bytes) is available (i.e., stored in an Axon). This is essential as many other data model elements allow
(or depend on) the concept of a file (as opposed to a hash).

The ``file:bytes`` type is a specialized :ref:`type-guid` type. A file can be uniquely represented by the
specific contents of the file itself. As it is impractical to use "all the bytes" as a primary property value,
it makes sense to use a shortened representation of those bytes - that is, a hash. MD5 collisions can now be
generated with ease, and SHA1 collisions were demonstrated in 2017. For this reason, Synapse uses the SHA256
hash of a file (considered sufficiently immune from collision attacks for the time being) as "unique enough"
to act as the primary property of a ``file:bytes`` node if available. Otherwise, a ``guid`` is generated and
used.

Indexing
++++++++

N/A

Parsing
+++++++

``file:bytes`` must be input using their complete primary property. It is impractical to manually type a
SHA256 hash or 128-bit ``guid`` value. For this reason ``file:bytes`` forms are most often specified by
referencing the node via a more human-friendly secondary property or by pivoting to the node. Alternately,
the ``file:bytes`` value can be copied and pasted for use in a query.

The primary property of a ``file:bytes`` node indicates how the node was created (i.e., via the SHA256 hash or via a guid):

- A node created using the SHA256 hash will have a primary property value consisting of ``sha256:`` prepended
  to the SHA256 hash:

  ``file:bytes=sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855``

- A node created using a ``guid`` will have a primary property value consisting of ``guid:`` prepended to the
  ``guid`` value:
  
  ``file:bytes=guid:22d4ed1b75c9eb5ff8070e0df1e8ed6b``

.. NOTE::
  
  When specifying a SHA256-based ``file:bytes`` node, entering the ``sha256:`` prefix is optional. The following
  are equivalent representations of the same file:
  
  ::
    
    file:bytes=sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
    
    file:bytes=e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
  


Insertion
+++++++++

A ``file:bytes`` node can be created in one of three ways:

SHA256 Hash
~~~~~~~~~~~

A SHA256 hash can be specified as the node’s primary property. The ``sha256:`` prefix can optionally be
specified, but is not required (it will be added automatically on node creation). Storm will recognize the
primary property value as a SHA256 hash and also set the ``:sha256`` secondary property. Any other secondary
properties must be set manually.

.. storm-cli:: [ file:bytes = 44daad9dbd84c92fa9ec52649b028b4c0f7d285407685778d09bad4b397747d0 ]

Because the SHA256 is considered unique (for now) for our purposes, the node is fully deconflictable. If
additional secondary properties such as ``:size`` or other hashes are obtained later, or if the actual file
is obtained, the node can be updated with the additional properties based on deconfliction with the SHA256 hash.

GUID Value
~~~~~~~~~~

The asterisk can be used to generate a ``file:bytes`` node with an arbitrary guid value:

.. storm-cli:: [ file:bytes = * ]

Alternately, a predictable ``guid`` can be generated by specifying a list of one or more values to the ``guid``
generator (for example, an MD5 and / or SHA1 hash):


.. storm-cli:: [ file:bytes = (63fcc49b2ac6cbd686f4d9704446c673,) :md5=63fcc49b2ac6cbd686f4d9704446c673 ]

Synapse does not recognize any strings passed to the ``guid`` generator as specific types or properties and will
not use values used to generate the ``guid`` to set any secondary property values; those properties must be
explicitly set (e.g., the ``:md5`` property in the example above).

See the section on type-specific behavior for :ref:`type-guid` types for additional discussion of the methods
used to create ``guid`` forms. (Note that `Dictionary Syntax`_ cannot be used to create guid-based ``file:bytes``
nodes.)

.. NOTE::
  
  "Deconflicting" ``file:bytes`` nodes based on an MD5 or SHA1 hash alone is potentially risky because both of
  those hashes are subject to collision attacks. In other words, two files that have the same MD5 hash or the
  same SHA1 hash are not guaranteed to be the same file based on that single hash alone.
  
  In short, creating ``file:bytes`` nodes using the MD5 and / or SHA1 hash can allow the creation of "potentially"
  deconflictable nodes when no other data is available. However, this deconfliction is subject to some limitations,
  as noted above. In addition, if the actual file (full bytes) or corresponding SHA256 hash is obtained later,
  it is not possible to "convert" a ``guid``-based ``file:bytes`` node to one whose primary property is based
  on the SHA256 hash.

Actual Bytes
~~~~~~~~~~~~

You can also create a ``file:bytes`` node by adding the actual file (set of bytes) to Synapse (specifically,
to Synapse's Axon storage). Adding the file will create the ``file:bytes`` node in the Cortex based on the
file's SHA256 value. Synapse will also calculate and set additional properties for the ``file:bytes`` node's
size and other hashes (e.g., MD5, SHA1, etc.).

Creating ``file:bytes`` nodes in this manner is often done programmatically (such as via a Synapse
:ref:`gloss-power-up`) that can download or ingest files. Other options include:

- the built-in Synapse :ref:`storm-wget` command;
- the  **Upload File** menu option available from the `Optic UI`_, which allows you to either
  upload a file from local disk, or download a file from a specified URL; or
- the ``pushfile`` tool, available from the CLI in the community version of Synapse (see :ref:`syn-tools-axon-put`).

.. TIP::
  
  Like other external (to Storm) commands, the pushfile tool is accessible from the Storm CLI (see :ref:`syn-tools-storm`)
  as ``!pushfile``.

Similarly, Storm’s HTTP library (:ref:`stormlibs-lib-inet-http`) could be leveraged to retrieve a web-based file and use the
returned bytes as input (potentially using Storm variables - see :ref:`storm-adv-vars`) to the ``guid`` generator.
A detailed discussion of this method is beyond the scope of this section; see the :ref:`stormtypes-libs-header`
technical documentation for additional detail.


Operations
++++++++++

It is impractical to manually type a ``file:bytes`` value when lifting or otherwise specifying a ``file:bytes`` node.
Nodes or values are typically copied and pasted, or pivoted to from other forms (such as a ``hash:md5``).

For some lift and filter operations, you may optionally specify ``file:bytes`` nodes using a sufficiently unique
partial match of the node's primary property. For example, the prefix operator ( ``^=`` ) may be used to specify
a unique prefix for the ``file:bytes`` node's SHA256 or guid value:

.. storm-pre:: [ file:bytes=sha256:021b4ce5c4d9eb45ed016fe7d87abe745ea961b712a08ea4c6b1b81d791f1eca :md5=8934aeed5d213fe29e858eee616a6ec7 :sha1=a7e576f41f7f100c1d03f478b05c7812c1db48ad :size=182820 :name=adobeupdater.exe ]
.. storm-cli:: file:bytes^=sha256:021b4ce5

**Usage Notes:**

- When using the prefix operator, the ``sha256:`` or ``guid:`` prefix string must be included.
- The length of the value that is "sufficiently unique" to select a single ``file:bytes`` will vary depending
  on the data in your instance of Synapse. If your selection criteria matches more than one ``file:bytes`` node,
  Synapse will return all matches.
- Alternatively, the regular expression operator ( ``~=`` ) may be used to specify a partial string match anywhere
  in the ``file:bytes`` node's primary property value (though this is an inefficient way to specify a ``file:bytes``
  node).


.. _type-guid:

guid
----

Within Synapse, the Globally Unique Identifier (``guid``) :ref:`data-type` refers to a 128-bit value used as a
form’s primary property. The value is represented in hex (e.g., ``4b0c2c5671874922ce001d69215d032f``).

The term should not be confused with the definition of GUID used by Microsoft_, or with other types of identifiers
used within Synapse (e.g., such as node identifiers / node idens).

The ``guid`` type is used as the primary property for forms that cannot be uniquely defined by a set of property values.
See the background documents on the Synapse data model for additional details on the :ref:`form-guid`.

See the section on :ref:`type-file` types for discussion of ``file:bytes`` as a specialized instance of a ``guid``
type.

Indexing
++++++++

N/A

Parsing
+++++++

It is impractical to manually type a guid value when lifting or otherwise specifying a guid form. While a guid can
be specified by a sufficiently unique prefix (e.g., ``ou:org^=4b0c2``), it is more common to reference a guid node
using a more human-friendly secondary property. For example:

.. storm-cli:: ou:org:name = vertex

Alternatively, the guid value can be copied and pasted.

Insertion
+++++++++

There are multiple ways to create guid nodes in Synapse. The critical consideration when deciding which method
is best for your use case is how (or whether) you can **deconflict** guid nodes.

Deconfliction
~~~~~~~~~~~~~

Synapse uses **deconfliction*** to ensure that nodes are unique within a Cortex. Deconfliction occurs when nodes are
created. Synapse deconflicts nodes based on their primary property value. When you attempt to create a node such as
an email address, Synapse checks to see whether an ``inet:email`` node with that value already exists. If so, Synapse
simply returns the existing node; otherwise, Synapse creates a new node:

.. storm-cli:: [ inet:email = training@vertex.link ]

Guid forms are also deconflicted based on their primary property - the guid value. However, guid forms are unique in
that the guid value has no obvious relationship to whatever the form represents. For example, the primary property of
an organization node (e.g., ``ou:org = 0efcf9b86fa373fab26112f2b29b94ca``) does not tell you anything about the organization
itself, such as its name, location, or URL.

Synapse guarantees that two ``ou:org`` nodes will never have the same guid. But since the guid value has no relationship to
the node's details (its secondary properties), it is possible for users (or processes) to inadvertently create multiple
guid nodes that represent the same thing:

.. storm-pre:: ou:name=vertex -> ou:org | delnode

.. storm-pre:: [ ou:org=* ou:org=* :name='the vertex project' :url=https://vertex.link/ ]

.. storm-cli:: ou:org:name='the vertex project'

The nodes above have different guid values - the nodes are unique, and have been deduplicated based on their primary property.
But looking at the secondary properties, it is clear (to a human) that both ``ou:org`` nodes are meant to represent The Vertex
Project - this is a problem, because we do not want two different nodes for one organization.

To avoid creating two guid nodes that represent the same thing, you may **also** need to check the secondary properties of
existing nodes before creating new ones. This process is called **secondary property deconfliction**.

.. NOTE::
  
  When creating guid nodes, where possible you want to choose a method that performs secondary property deconfliction for you -
  specifically, `Dictionary Syntax`_ is preferred where possible. `Predictable Guids`_ and `Arbitrary Guids`_ can also be used,
  but you should consider their pros / cons and appropriate use cases.

.. _guid-dictionary:

Dictionary Syntax
~~~~~~~~~~~~~~~~~

Dictionary guid constructor syntax ("dictionary syntax" for short) is the preferred method for creating guid nodes where
possible. This method will:

- perform secondary property deconfliction;
- generate a predictable guid; and
- automatically set set secondary property values when creating a new node.

.. TIP::
  
  Dictionary guid constructor syntax is referred to as "dictionary syntax" here (it's easier to type or say). You may also
  encounter the term **guid constructor**, which is sometimes shortened to **gutor**. Although there are multiple ways to construct
  a guid (as described below), the terms "guid constructor" and "gutor" refer specifically to  dictionary guid constructor syntax.

Dictionary syntax uses a JSON dictionary with a set of key:value pairs to deconflict and create guid nodes. The key:value pairs are
secondary property names and values to deconflict on.

Synapse will perform secondary property deconfliction using the property names and values in the dictionary, and will return the node
if found. Otherwise, Synapse creates a new node (using the dictionary as input to generate a predictable guid) and sets the property
values specified in the dictionary.

.. NOTE::
  
  A **predictable** guid is one that can be generated consistently - that is, the same data will result in the same guid each time.
  They may also be referred to as stable, repeatable, or re-encounterable guids. (Contrast this with `Arbitrary Guids`_, below.)

**Example:**

You want to create an organization node for The Vertex Project, deconflicting on the company name and URL.

.. storm-pre:: ou:org:name='the vertex project' | delnode

.. storm-cli:: [ ou:org = ( { "name": "the vertex project", "url": "https://vertex.link" } ) ]

In the query above:
- the curly braces ( ``{ }`` ) enclose the key:value pairs in the JSON dictionary;
- the parentheses ( ``( )`` ) enclose the information used to deconflict the node and / or create the guid (i.e., the dictionary); and
- the square brackets ( ``[ ]`` ) are the Storm edit brackets.

Note that dictionary syntax is "model aware" - because the key:value pairs are property names and values, Synapse can use this
information to set the listed properties, including normalizing the values if necessary.

.. TIP::
  
  Synapse implements several Storm commands known as generator ("gen") commands. These commands use dictionary syntax
  "under the hood" to deconflict and create some common guid nodes. (See the :ref:`storm-gen` section in the :ref:`storm-ref-cmd`
  for available generator commands (or run ``help`` from your Synapse CLI).)

**Notes:**

- Dictionary syntax will automatically deconflict on "primary" and "alternate" secondary properties, where appropriate. For example,
  in the query above, Synapse will check both the ``:name`` and ``:names`` properties of existing ``ou:org`` nodes for the
  value ``'the vertex project'``.

- When choosing a secondary properties to deconflict on (particularly for automated or bulk ingest), you should:
  
  - Select properties that are unique enough to allow deconfliction. For example, an organization's name is reasonably unique;
    its location (``:loc``) is not.
  - Select properties that will always be present in your source data. If a property is not present, you can't use it to deconflict
    or create a node.
  - If you ingest data about the same objects (for example, organizations or TLS certificates) from multiple data sources and need
    to deconflict across all of them, select properties that will be present in all of the sources. 

- Deconfliction is performed using the full set of properties provided in the JSON dictionary; Synapse will look for
  an existing node that has **all** of the listed values. When choosing key:value pairs for the dictionary, we recommend using
  the minimum number of entries needed to uniquely identify / deconflict a node. (If you use too many values, you may fail to
  identify an existing node if it has only some of those values set.)
  
- You can use the values of ``array`` type properties for deconfliction, but the value to deconflict on must match **all**
  values present in the array. In other words, if your dictionary includes one array value in the key:value pair but the
  existing node has three values for that property, deconfliction will fail.
  
  Let's say you want to deconflict an ``ou:org`` node using the organization's FQDN (from the ``:dns:mx`` array property).
  Consider the following existing node:
  
.. storm-cli:: ou:org:name='the vertex project' [ :dns:mx=( vertex.link, vtx.lk ) ]
    
  The following dictionary syntax identifies and lifts the node:
  
.. storm-cli:: [ ou:org = ( { "name": "the vertex project", "dns:mx": [ "vtx.lk", "vertex.link" ] } ) ]
  
  (Note that the **order** of the array elements in the dictionary does not matter, but **all** elements must be present.)
  
  The following dictionary syntax only contains one of the ``:dns:mx`` values, so fails to deconflict and creates a new node:
  
.. storm-cli:: [ ou:org = ( { "name": "the vertex project", "dns:mx": [ "vertex.link" ] } )  ] ou:org:name='the vertex project' | uniq

- You can use literals or variables within the JSON dictionary. For example:
  
.. storm-pre:: ou:org:name='the vertex project' | delnode
  
.. storm-cli:: [ ou:org = ( { "name": "the vertex project", "url": "https://vertex.link/" } ) ]
  
.. storm-cli:: $name='the vertex project' $url=https://vertex.link/ [ ou:org = ( { "name": $name, "url": $url } ) ]

- When creating a new node using dictionary syntax, Synapse uses an algorithm (the guid generator or "guid grinder")
  to generate a predictable guid using the dictionary content as input. (The same algorithm is implemented in the ``$lib.guid()``
  library (see :ref:`stormlibs-lib-guid`.)
  
  The dictionary is converted to a sorted (alphabetical) list of ``(<key>, <normalized value>)`` tuples that are fed to the
  algorithm. Given the following query:
  
.. storm-cli:: [ ou:org = ( { "name": "The Vertex Project", "url": "https://vertex.link/" } ) ]
  
  ...the dictionary is "converted" to the following for purposes of creating a predictable guid:
  
.. storm-cli:: [ ou:org = ( (name, 'the vertex project'), (url, https://vertex.link/) ) ]
  
  The tuples within the outermost parentheses are fed to the algorithm to create the guid. Note that second query
  generated the same guid as the dictionary syntax in our first query. 
  
  Note that the dictionary values are **normalized** based on their type. In the above example the value "The Vertex Project" is
  normalized to lowercase when used to generate the guid. 


.. _guid-predictable:

Predictable Guids
~~~~~~~~~~~~~~~~~

You can use the guid generation algorithm described above to create a predictable guid **without** performing secondary
property deconfliction.

To create a predictable guid, provide a list of ordered inputs (enclosed in parentheses) that will be used to generate the guid:

.. storm-pre:: ou:org:name='the vertex project' | delnode

.. storm-cli:: [ ou:org = ('the vertex project', 'https://vertex.link/') ]

Note that this is a "blank" node with no secondary properties set. You can set the properties once the node has been
created, or set them as part of your original query:

.. storm-cli:: [ ou:org = ('the vertex project', 'https://vertex.link/') :name='the vertex project' :url=https://vertex.link/ ]

.. NOTE::
  
  Secondary property values are commonly used as inputs, but this method does **not** perform any secondary property deconfliction.
  The query above creates a predictable guid, but does not check whether an ``ou:org`` node with ``:name='the vertex project'
  or ``:url=https://vertex.link/`` already exists.

Secondary property deconfliction (provided by dictionary syntax) is almost always desirable to avoid duplicate nodes. However,
predictable guids may be useful when:

- dictionary syntax is not an option. There may be cases where an object's secondary properties are not unique enough
  to be used for deconfliction, or data sources are sparse and you cannot identify a set of properties that are guaranteed
  to be present across all data sources.

- you have a unique data source. In this case, you can use predictable guids to ensure that individual nodes are created
  in a repeatable way (in case you need to reingest the same data) without worrying about deconfliction (because there is
  no alternate source for the same data to deconflict with). Examples of this type of unique data include internal log or
  alert data or reporter-specific data (e.g., nodes with ``:reporter`` or ``:reporter:name`` properties) where the
  reporter is - by definition- the unique source for that information).

**Notes:**

- The set of inputs must be sufficient to create a unique node. Be sure to choose inputs that will always be present in
  the data source.

- If the nodes being created are event-based (e.g., include a unique timestamp), then the timestamp should be used as one of
  the inputs.

- When using this method to deconflict data from a unique (single) data source, we recommend that you include the source
  (e.g., the name of the data source) as one of the inputs.

- You can specify input values as literals or variables. The guid is generated using the same algorithm implemented by
  the ``$lib.guid()`` library (see :ref:`stormlibs-lib-guid`). All of the following are valid:
  
.. storm-pre:: ou:org:name='the vertex project' | delnode
  
.. storm-cli:: [ ou:org = ('the vertex project', https://vertex.link/) ]
  
.. storm-cli:: $name='the vertex project' $url=https://vertex.link/ [ ou:org = ($name, $url) ]
  
.. storm-cli:: $guid = $lib.guid('the vertex project', https://vertex.link/) [ ou:org = $guid ]
  
.. storm-cli:: $name='the vertex project' $url=https://vertex.link/ $guid = $lib.guid($name, $url) [ ou:org = $guid ]
  
.. storm-cli:: $name='the vertex project' $url=https://vertex.link/ [ ou:org = ( $lib.guid($name, $url) ) ]
  
- The input to the algorithm is interpreted as a structured list of **string values** (i.e., ``(str_0, str_1, str_2...str_n)``).
  To consistently generate the same guid, each string must be **identical** (note that strings are case sensitive) and in the
  **same order** each time.

.. _guid-arbitrary:

Arbitrary Guids
~~~~~~~~~~~~~~~

You can specify the asterisk ( ``*`` ) as the primary property value when creating a guid node. This tells
Synapse to generate a unique, **arbitrary** guid for the node. For example:

.. storm-cli:: [ ou:org = * ]

Note that this is a "blank" node with no secondary properties set. You can set the properties once the node has
been created, or set them as part of your original query:

.. storm-cli:: [ ou:org = * :name='the vertex project' ]

.. WARNING::
  
  The guid values are truly arbitrary; they are only guaranteed to be unique values. No other deconfliction is
  performed. If you run the query above a second time, Synapse will create a second ``ou:org`` node with the same
  ``:name`` but a **new** unique, arbitrary guid.

Arbitrary guids are the simplest to create (so are often favored for one-off, manual node creation). However,
they are the most risky from a deconfliction standpoint. No secondary property deconfliction is used, and
the guids that are generated are not predictable.

Using arbitrary guids may be acceptable when:

- you will **never** need to deconflict the data, so the guid value doesn't matter. (It is rare that you never
  need to deconflict or reingest data, but this may be the case for some highly unique data sets.)
- a user needs to manually create a guid node, and the asterisk ( ``*`` ) is the simplest means to do so
  (e.g., if a command or other automation does not exist to help create the kind of node in question).
  
In particular users (who are most likely to make use of this method due to its simplicity) should understand
the risks and trade-offs with respect to deconfliction. Alternatively, users may be able to:

- make use of Storm generator ("gen") commands, where available. (See the :ref:`storm-gen` section in the
  :ref:`storm-ref-cmd` for available generator commands (or run ``help`` from your Synapse CLI).)

- create other types of automation (macros, node actions, etc.) as appropriate to help users create nodes
  without needing to know the Storm syntax for dictionary syntax or predictable guids.
  
- if these options are not available, train users to manually check for duplicate nodes before creating a
  new, arbitrary guid form. (This is not foolproof as users will not be able to discover duplicate nodes that
  may exist in forks or other views that are not visible to the user.)

- decide to live with any risk. The number of user-created nodes is likely to be small compared to the volume
  of data ingested through Power-Ups or other automation. Nodes initially created with arbitrary guids may
  later be "recognized" (and deconflicted appropriately) by automation that uses other guid node creation
  strategies.

Operations
++++++++++

Because guid values are unwieldy to use on the command line (outside of copy and paste operations), it is often
easier to lift guid nodes by a unique secondary property.

**Examples:**

Lift an org node by a single name in the names property:

.. storm-pre:: [ ou:org = * :names = (choam,) :name = 'combine honnete ober advancer mercantiles' ]
.. storm-cli:: ou:org:names *[ = choam ]

Lift a DNS request node by the name used in the DNS query:

.. storm-pre:: [ inet:dns:request=* :time="2020/04/30 09:30:33.000" :query:name=pop.seznam.cz :query:name:fqdn=pop.seznam.cz ]
.. storm-cli:: inet:dns:request:query:name = pop.seznam.cz

It is also possible to lift and filter guid nodes using a "sufficiently unique" prefix match of the guid value.

**Example:**

Lift a ``ps:contact`` node by a partial prefix match:

.. storm-pre:: [ ps:contact=13c9663e5f553014eb50d00bb7c6945a :orgname="kaspersky lab" :name="seongsu park" ]
.. storm-cli:: ps:contact ^= 13c9663e

The length of the value that is "sufficiently unique" will vary depending on the data in your instance of Synapse.
If your selection criteria matches more than one node, Synapse will return all matches.

When **setting** or **updating** a secondary property that is a guid value, you may use a "human friendly"
Storm query (specifically a subquery) to reference the node whose primary property (guid value) you wish to
set for the secondary property.

**Example:**

Set the ``:org`` property for a ``ps:contact`` node to the guid value of the associated ``ou:org`` node using
a Storm query:

.. storm-pre:: [ (ps:contact=* :name='ron the cat' :title='cattribution analyst') (ou:org=* :name=vertex) ]

.. storm-cli:: ps:contact:name = 'ron the cat' [ :org = { ou:org:name = vertex } ]

.. NOTE::
  
  The Storm query used to specify the guid node must return exactly one node. If the query returns more
  than one node, or does not return any nodes, Synapse will generate an error.

See :ref:`prop-add-mod-subquery` for additional details.


.. _type-inet-fqdn:

inet:\fqdn
----------

**Fully qualified domain names** (FQDNs) are structured as a set of string elements separated by the dot
( ``.`` ) character. The Domain Name System acts as a "reverse hierarchy" (operating from right to left
instead of from left to right) separated along the dot boundaries - i.e., ``com`` is the hierarchical root
for domains such as ``google.com`` or ``microsoft.com``.

Because of this logical structure, Synapse includes certain optimizations for working with ``inet:fqdn`` types:

- Reverse string indexing on ``inet:fqdn`` types.
- Default values for the secondary properties ``:issuffix`` and ``:iszone`` of a given ``inet:fqdn`` node based
  on the values of those properties for the node’s parent domain.

Indexing
++++++++

Synapse performs **reverse string indexing** on ``inet:fqdn`` types. Domains are indexed in full reverse order -
that is, the domain ``this.is.my.domain.com`` is indexed as ``moc.niamod.ym.si.siht`` to account for the
"reverse hierarchy" implicit in the DNS structure.

Parsing
+++++++

N/A

Insertion
+++++++++

When ``inet:fqdn`` nodes are created (or modifications to certain properties are made), Synapse uses some
built-in logic to set certain secondary properties related to zones of control (specifically, ``:issuffix``,
``:iszone``, and ``:zone``).

The reverse hierarchy implicit in dotted FQDNs represents elements such as *<host>.<domain>.<suffix>*, but
can also represent implicit or explicit **zones of control.** The term "zone of control" is loosely defined,
and is not meant to represent control or authority by any specific organization or entity. Instead, "zone of
control" can be thought of as a boundary within an individual FQDN hierarchy where control of a portion of
the domain namespace shifts from one entity or owner to another.

A simple example is the ``com`` top-level domain (managed by Verisign) vs. the domain ``microsoft.com``
(controlled by Microsoft Corporation). ``Com`` represents one zone of control where ``microsoft.com`` 
represents another.

The ``inet:fqdn`` form in the Synapse data model uses several secondary properties that relate to zones of
control:

- ``:issuffix`` = primary zone of control
- ``:iszone`` = secondary zone of control
- ``:zone`` = authoritative zone for a given domain or subdomain

(**Note:** contrast ``:zone`` with ``:domain`` which simply represents the next level "up" in the hierarchy
from the current domain).

Synapse uses the following logic for suffixes and zones upon ``inet:fqdn`` creation:

1. All domains consisting of a single element (such as ``com``, ``museum``, ``us``, ``br``, etc.) are
   considered **suffixes** and receive the following default values:
   
   - ``:issuffix = 1``
   - ``:iszone = 0``
   - ``:zone = <none / property not created>``
   - ``:domain = <none / property not created>``

2. Any domain whose **parent domain is a suffix** is considered a **zone** and receives the following default
   values:
   
   - ``:issuffix = 0``
   - ``:iszone = 1``
   - ``:zone = <set to self>``
   - ``:domain = <set to parent domain>``

3. Any domain whose **parent domain is a zone** is considered a "normal" subdomain and receives the following
   default values:
   
   - ``:issuffix = 0``
   - ``:iszone = 0``
   - ``:zone = <set to parent domain>``
   - ``:domain = <set to parent domain>``

4. Any domain whose parent domain is a "normal" subdomain receives the following default values:
   
   - ``:issuffix = 0``
   - ``:iszone = 0``
   - ``:zone = <set to first fqdn “up” the domain hierarchy with :iszone = 1>``
   - ``:domain = <set to parent domain>``

.. NOTE::
  
  The above logic is **recursive** over all nodes in a Cortex. Changing an ``:issuffix`` or ``:iszone``
  property on an existing ``inet:fqdn`` node will not only modify that node, but also propagate any changes
  associated with those properties to any existing subdomains.


Potential Limitations
~~~~~~~~~~~~~~~~~~~~~

This logic works well for single-element top-level domains (TLDs) (such as ``com`` vs ``microsoft.com``).
However, it  does not address cases that may be relevant for certain types of analysis, such as:

- **Top-level country code domains and their subdomains.** Under Synapse’s default logic ``uk`` is a suffix
  and ``co.uk`` is a zone. However, ``co.uk`` could **also** be considered a suffix in its own right, because
  subdomains such as ``somecompany.co.uk`` are under the control of the organization that registers them. In
  this case, ``uk`` would be a suffix, ``com.uk`` could be considered both a suffix **and** a zone, and
  ``somecompany.co.uk`` could be considered a zone.

- **Special-case zones of control.** Some domains (such as those used to host web-based services) can be
  considered specialized zones of control. In these cases, the service provider typically owns the "main"
  domain (such as ``wordpress.com``) but individual customers can register personal subdomains for their
  hosted services (such as ``joesblog.wordpress.com``). The division between ``wordpress.com`` and individual
  customer subdomains could represent different zones of control. In this case, ``com`` would be a suffix, 
  ``wordpress.com`` could be considered both a suffix **and** a zone, and ``joesblog.wordpress.com`` could be
  considered a zone.

Examples such as these are **not accounted for** by Synapse’s suffix / zone logic. The definition of additional
domains as suffixes and / or zones is an implementation decision (though once the relevant properties are set,
the changes are propagated recursively as noted above).

Operations
++++++++++

Because of Synapse’s reverse string indexing for ``inet:fqdn`` types, domains can be lifted or filtered based
on matching any partial domain suffix string. The asterisk ( ``*`` ) is the extended operator used to perform
this operation. The asterisk does **not** have to be used along dot boundaries but can match anywhere in any FQDN element.

**Examples**

Lift all domains that end with ``yahooapis.com``:

.. storm-pre:: [ inet:fqdn=ayuisyahooapis.com inet:fqdn=micyuisyahooapis.com inet:fqdn=usyahooapis.com ]
.. storm-cli:: inet:fqdn='*yahooapis.com'


Lift all domains ending with ``s.wordpress.com``:

.. storm-pre:: [ inet:fqdn=cats.wordpress.com inet:fqdn=dogs.wordpress.com inet:fqdn=s.wordpress.com inet:fqdn=www.sss.wordpress.com ]
.. storm-cli:: inet:fqdn="*s.wordpress.com"


Downselect a set of DNS A records to those with domains ending with ``.museum``:

.. storm-pre:: [ inet:dns:a=(woot.com,1.2.3.4) inet:dns:a=(woot.museum,5.6.7.8) inet:dns:a=(woot.link,7.7.7.7) ] +:fqdn="*.museum"
.. storm-cli:: inet:dns:a +:fqdn="*.museum"

**Usage Notes**

- Because the asterisk is a non-alphanumeric character, the string to be matched must be enclosed in single or
  double quotes (see :ref:`storm-whitespace-literals`).
- Because domains are reverse-indexed instead of prefix indexed, for **lift** operations, partial string matching
  can only occur based on the end (suffix) of a domain. It is not possible to **lift** FQDNs by prefix. For example,
  ``inet:fqdn^=yahoo`` is invalid.
- Domains can be **filtered** by prefix (``^=``). For example, ``inet:fqdn="*.biz" +inet:fqdn^=smtp`` is valid.
- Domains cannot be **filtered** based on suffix matching (note that a "lift by suffix" is effectively a combined
  "lift and filter" operation).
- Domains can be lifted or filtered using the regular expression (regex) extended operator (``~=``). For example
  ``inet:fqdn~=google`` is valid (see :ref:`lift-regex` and :ref:`filter-regex`).

.. _type-inet-ipv4:

inet\:ipv4
----------

IPv4 addresses are stored as integers and represented (displayed) to users as dotted-decimal strings.

Indexing
++++++++

IPv4 addresses are indexed as integers. This optimizes various comparison operations, including greater than /
less than, range, etc.

Parsing
+++++++

While IPv4 addresses are stored and indexed as integers, they can be input into Storm (and used within Storm
operations) as any of the following.

- integer: ``inet:ipv4 = 3232235521``
- hex: ``inet:ipv4 = 0xC0A80001``
- dotted-decimal string: ``inet:ipv4 = 192.168.0.1``
- range: ``inet:ipv4 = 192.168.0.1-192.167.0.10``
- CIDR: ``inet:ipv4 = 192.168.0.0/24``

Insertion
+++++++++

The ability to specify IPv4 values using either range or CIDR format allows you to "bulk create" sets of
``inet:ipv4`` nodes without the need to specify each address individually.

**Examples**

**Note:** results (output) not shown below due to length.

Create ten ``inet:ipv4`` nodes:


.. storm-pre:: [ inet:ipv4 = 192.168.0.1-192.168.0.10 ]
::

    [ inet:ipv4 = 192.168.0.1-192.168.0.10 ]


Create the 256 addresses in the range 192.168.0.0/24:


.. storm-pre:: [ inet:ipv4 = 192.168.0.0/24 ]
::

    [ inet:ipv4 = 192.168.0.0/24 ]


Operations
++++++++++

Similar to node insertion, lifting or filtering IPV4 addresses by range or by CIDR notation will operate on
every ``inet:ipv4`` node that exists within the Cortex and falls within the specified range or CIDR block. 
This allows operating on multiple contiguous IP addresses without the need to specify them individually.

**Examples**

Lift all ``inet:ipv4`` nodes within the specified range that exist within the Cortex:


.. storm-pre:: [ inet:ipv4=169.254.18.30 inet:ipv4=169.254.18.36 inet:ipv4=169.254.18.53 ]
.. storm-cli:: inet:ipv4 = 169.254.18.24-169.254.18.64

Filter a set of DNS A records to only include those whose IPv4 value is within the 172.16.* RFC1918 range:


.. storm-pre:: [ inet:dns:a=(woot.com,1.2.3.4) inet:dns:a=(woot.com,127.0.0.1) inet:dns:a=(woot.com,172.16.47.12) ]
.. storm-cli:: inet:dns:a:fqdn=woot.com +:ipv4=172.16.0.0/12

.. _type-int:

int
---

An ``int`` is an integer value. Synapse stores, indexes, and displays integer values as decimal integers, but will also accept as hex or octal values as input.

Indexing
++++++++

N/A

Parsing
+++++++

When adding or modifying integer values, Synapse will accept integer, hex (preceded by 0x), and octal (preceded by 0o) values and represent them as decimal integer values.

**Examples**

Set the ``:count`` of the ``biz:bundle`` to 42:

.. storm-pre:: [ biz:bundle=(350,) ]
.. storm-cli:: biz:bundle=9688955d141aae88194277e74d82084d [ :count=42 ]

Use a hex value to set the ``:ip:proto`` property for the ``inet:flow`` node to 6:

.. storm-pre:: [ inet:flow=(tcp://142.118.95.50, tcp, 142.118.95.50) :dst=tcp://142.118.95.50 :dst:proto=tcp :dst:ipv4=142.118.95.50 ]
.. storm-cli:: inet:flow=684babd42810ae9dc11132805abc2831 [ :ip:proto=0x06 ]

Use an octal value to set the ``:posix:perms`` property for the ``file:archive:entry`` node to 755:

.. storm-pre:: [ file:archive:entry=(sha256:0c72088f529dc53e813de8e7df47922b1a9137924e072468559f7865eb7ad18b,20230811 11:33:00, ozzie) :user=ozzie :added="20230811 11:33:00" :file=sha256:0c72088f529dc53e813de8e7df47922b1a9137924e072468559f7865eb7ad18b ]
.. storm-cli:: file:archive:entry=3a24e1008b43bc2f1e35b3e872f201fc [ :posix:perms=0o426 ]

Insertion
+++++++++

Same as for parsing.

Operations
++++++++++

Use integer, hex, or octal values to lift and filter integer types using standard comparison operators.

**Examples**

Lift all ``risk:alert`` nodes where the ``:priority`` is set to less than 10:

.. storm-pre:: [ risk:alert=(outbound traffic to SOC-reported IP, 20230801 09:00:00, 9) :desc="outbound traffic to SOC-reported IP" :name="suspicious outbound traffic" :detected="20230801 09:00:00" :priority=8]
.. storm-cli:: risk:alert:priority<10

Lift all ``inet:flow`` nodes tagged with ``#my.tag`` and filter to include only those where the ``:ip:proto`` property is set to the hex equivalent of 6:

.. storm-pre:: [ inet:flow=(tcp://62.152.42.139, tcp, 62.152.42.139) :dst=tcp://62.152.42.139 :dst:proto=tcp :dst:ipv4=62.152.42.139 :ip:proto=6 +#my.tag]
.. storm-cli:: inet:flow#mytag +:ip:proto=0x06

Use an octal value to lift all ``it:group`` nodes where the ``:posix:gid`` values equate to 278:

.. storm-pre:: [ it:group=(research, a6f4147c23421ef47a1fabea899b3aeb, threat researchers group) :desc="threat researchers group" :name="research" :host=a6f4147c23421ef47a1fabea899b3aeb :posix:gid=278 ] 
.. storm-cli:: it:group:posix:gid=0o426


.. _type-ival:

ival
----

``ival`` ("interval") is a specialized type consisting of two ``time`` types in a paired ``(<min>, <max>)``
relationship. As such, the individual values in an ``ival`` are subject to the same specialized handling as
individual :ref:`type-time` values.

``ival`` types have their own optimizations in addition to those related to ``time`` types.

Indexing
++++++++

N/A

Parsing
+++++++

An ``ival`` type is typically specified as two comma-separated time values enclosed in parentheses. Alternately,
an ``ival`` can be specified as a single time value with no parentheses (see **Insertion** below for ``ival``
behavior when specifying a single time value).

Single or double quotes are required in accordance with the standard rules for using :ref:`storm-whitespace-literals`.
For example:

- ``.seen=("2017/03/24 12:13:27", "2017/08/05 17:23:46")``
- ``+#sometag=(2018/09/15, "+24 hours")``
- ``.seen=2019/03/24``

As ``ival`` types are a pair of values (i.e., an explicit minimum and maximum), the values must be placed in
parentheses and separated by a comma: ``(<min>, <max>)``. The parser expects two **explicit** values.

An ``ival`` can also be specified as a single time value, in which case the value must be specified **without**
parentheses: ``<time>``. See **Insertion** below for ``ival`` behavior when adding vs. modifying using a single
time value vs. a ``(<min>, <max>)`` pair.

When entering an ``ival`` type, each time value can be input using most of the acceptable formats for :ref:`type-time`
types, including explicit times (including lower resolution times and wildcard times), relative times, and the
special values ``now`` and ``?``.

``ival`` types also support relative times using ``+-`` format to represent both a positive and negative offset
from a given point (i.e., ``"+-1 hour"``).

When entering relative times in an ``ival`` type:

- A relative time in the **first** (``<min>``) position is calculated relative to the **current time** (``now``).
- A relative time in the **second** (``<max>``) position is calculated relative to the **first** (``<min>``) time.

For example:

- ``.seen="+1 hour"`` means from the current time (now) to one hour after the current time.
- ``.seen=(2018/12/01, "+1 day")`` means from 12:00 AM December 1, 2018 to 12:00 AM December 2, 2018.
- ``.seen=(2018/12/01, "-1 day")`` means from 12:00 AM November 30, 2018 to 12:00 AM December 1, 2018.
- ``.seen=(now, "+-5 minutes")`` means from 5 minutes ago to 5 minutes from now.
- ``.seen=("-30 minutes", "+1 hour")`` means from 30 minutes ago to 30 minutes from now.

When specifying minimum and maximum times for an ``ival`` type (or when specifying minimum and maximum ``time``
values to the ``*range=`` comparator), the following restrictions should be kept in mind:

- Minimums and maximums that use explicit times and / or special terms (``now``, ``?``) should be specified in
  ``<min>, <max>`` order.

  - Specifying a ``<max>, <min>`` order will **not** result in an error message, but because it results in an
    exclusionary time window, it will not return any nodes (i.e., no time / interval can be both greater than
    a max value and less than a min value).

  - Similarly, combinations of relative times that result in an effective ``<max>, <min>`` after relative offsets
    are calculated are allowed (will not generate an error), but will result in an exclusionary time window that
    does not return any nodes.

- Values that result in a nonsensical ``<min>, <max>`` are not allowed and will generate an error. For example:

  - The special value ``?`` cannot be used as a minimum value in a ``(<min>, <max>)`` pair.
  - A ``+-`` relative time cannot be used as a minimum value in a ``(<min>, <max>)`` pair.
  - When specifying a ``+-`` relative time as the maximum value in a ``(<min>, <max>)`` pair, an explicit
    ``<min>`` value is also required (i.e., either an explicit time or ``now``).

Insertion
+++++++++

- When **adding** an ``ival`` as a ``(<min>, <max>)`` pair, the ``ival`` can be specified as described above.

  - If the values for ``<min>`` and ``<max>`` are identical, then ``<min>`` will be set to the specified value
    and ``<max>`` will be set to ``<min>`` plus 1 ms.

- When **adding** an ``ival`` as a single time value, it must be specified **without** parentheses.

  - When a single time value is used, the ``<min>`` value will be set to the specified time and the ``<max>``
    will be set to the ``<min>`` time plus 1 ms.

- When **modifying** an existing ``ival`` property (including tag timestamps) with either a ``(<min>, <max>)``
  pair or a single time value, the existing ``ival`` is **not** simply overwritten (as is the norm for modifying
  properties - see :ref:`storm-ref-data-mod`). Instead, the ``<min>`` and / or ``<max>`` are **only** updated
  if the new value(s) are:

  - Less than the current ``<min>``, and / or
  - Greater than the current ``<max>``.
  
  This means that once set, ``<min>`` and ``<max>`` can only be "pushed out" to a lower minimum and / or a higher
  maximum. Specifying a time or times that fall **within** the current minimum and maximum will have no effect
  (i.e., the current values will be retained).
  
  This means that it is not possible to "shrink" an ``ival`` directly; to specify a higher minimum or a lower
  maximum (or to remove the timestamps altogether), you must delete the ``ival`` property (or remove the timestamped
  tag) and re-add it with the updated values.

Operations
++++++++++

``ival`` types can be lifted and filtered (see :ref:`storm-ref-lift` and :ref:`storm-ref-filter`) with the standard
equivalent ( ``=`` ) operator, which will match the **exact** ``<min>`` and ``<max>`` values specified.

**Example:**

Lift the DNS A nodes whose observation window is **exactly** from 2018/12/13 01:05 to 2018/12/16 12:57:


.. storm-pre:: [ inet:dns:a=(yoyodyne.com,16.16.16.16) .seen=("2018/12/13 01:05", "2018/12/16 12:57") ]
.. storm-cli:: inet:dns:a.seen=("2018/12/13 01:05", "2018/12/16 12:57")

``ival`` types cannot be used with comparison operators such as "less than" or "greater than or equal to".

``ival`` types are most often lifted or filtered using the custom interval comparator (``@=``) (see :ref:`lift-interval`
and :ref:`filter-interval`). ``@=`` is intended for time-based comparisons (including comparing ``ival`` types with
``time`` types).

**Example:**

Lift all the DNS A nodes whose observation window overlaps with the interval of March 1, 2019 through April 1, 2019:


.. storm-pre:: [ ( inet:dns:a=(hurr.com,4.4.4.4) .seen=('2019/01/05 09:38', '2019/03/12 18:17') ) ( inet:dns:a=(derp.net,8.8.8.8) .seen=('2019/03/08 07:26','2019/03/22 10:14') ) ( inet:dns:a=(blergh.org,2.2.2.2) .seen=('2019/03/28 22:22','2019/04/27 00:03') ) ]
.. storm-cli:: inet:dns:a.seen@=(2019/03/01, 2019/04/01)


``ival`` types cannot be used with the ``*range=`` custom comparator. ``*range=`` can only be used to specify a
range of individual values (such as ``time`` or ``int``).

.. TIP::
  
  By definition, an ``ival`` is a **pair** of date/time values treated as a single combined value. This means that
  when using variables_ to work with ``ival`` types, the full value of the property is assigned to the variable by
  default. For example, given a node (such as an ``inet:dns:a`` node) with a ``.seen`` value of ``(2023/07/08 11:19:02, 2023/12/14 21:18:47)``,
  the variable assignment ``$time = .seen`` will assign the **pair** of date/times to ``$time``.
  
  You can access each date/time of an ``ival`` independently by assigning the value to a **pair** of variables
  as follows:
  
  ``( $min, $max ) = .seen``
  
  ``$min`` will represent the value ``2023/07/08 11:19:02`` and ``$max`` will represent the value ``2023/12/14 21:18:47``.


.. _type-loc:

loc
---

``Loc`` is a specialized type used to represent geopolitical locations (i.e., locations within geopolitical
boundaries) as a series of user-defined dot-separated hierarchical strings - for example, 
*<country>.<region>.<city>*. This allows specifying locations such as ``us.fl.miami``, ``gb.london``,
and ``ca.on.toronto``.

``Loc`` is an extension of the :ref:`type-str` type. However, because ``loc`` types use strings that comprise a
dot-separated hierarchy, they exhibit slightly modified behavior from standard string types for certain operations.

Indexing
++++++++

The ``loc`` type is an extension of the :ref:`type-str` type and is **prefix-indexed** like other strings.
However, the use of dot-separated boundaries impacts operations using ``loc`` values.

``loc`` values are normalized to lowercase.

Parsing
+++++++

``loc`` values can be input using any case (uppercase, lowercase, mixed case) but will normalized to lowercase. 

Components of a ``loc`` value must be separated by the dot ( ``.`` ) character. A ``loc`` value that
consists of a single element does not require a trailing dot.

The dot is a reserved character for the ``loc`` type and is used to separate string elements along hierarchical
boundaries. The use of the dot as a reserved boundary marker impacts some operations using the ``loc`` type. Note
that this means the dot cannot be used as part of a location string. For example, the following location value
would be interpreted as a hierarchical location with four elements (``us``, ``fl``, ``st``, and ``petersburg``):

- ``:loc = us.fl.st.petersburg``

To appropriately represent the "city" element of the above location, an alternate syntax must be used. For example:

- ``:loc = us.fl.stpetersburg``
- ``:loc = "us.fl.st petersburg"``
- ``:loc = us.fl.st_petersburg``
- ...etc.

As an extension of the ``str`` type, ``loc`` types are subject to Synapse’s restrictions regarding using
:ref:`storm-whitespace-literals`.

Insertion
+++++++++

Same as for parsing.

As ``loc`` values are simply dot-separated strings, the use or enforcement of any specific convention for
geolocation values and hierarchies is an implementation decision.

Operations
++++++++++

The use of the dot character ( ``.`` ) as a reserved boundary marker impacts prefix ( ``^=`` ) and equivalent
( ``=`` ) operations using the ``loc`` type.

Prefix Operator
~~~~~~~~~~~~~~~

When **lifting** or **filtering** on ``loc`` property values using the prefix comparison operator ( ``^=`` ), the
specified value must fall on a dot boundary.

String and string-derived types are **prefix-indexed** to optimize lifting or filtering strings that start
with a given substring. For standard strings, the prefix operator can be used with strings of arbitrary length.
However, for ``loc`` types, the prefix operator works along dot boundaries. This is because it is generally more
analytically meaningful to lift all locations within the US (``^= us``) or within Florida (``^= us.fl``) than
it is to lift all locations in the US within states that start with "V" (``^= us.v``).

Prefix comparison for ``loc`` types is useful because it easily allows lifting or filtering at any appropriate
level of resolution within the dotted hierarchy:

**Examples:**

Lift all organizations located in Turkey (``tr``):

.. storm-pre:: [ ( ou:org=* :name='republic of turkey ministry of foreign affairs' :loc=tr.ankara ) ( ou:org=* :name='adeo it consulting services' :loc=tr.istanbul ) ]
.. storm-cli:: ou:org:loc ^= tr


Lift all IP addresses geolocated in the province of Ontario, Canada (``ca.on``):


.. storm-pre:: [ ( inet:ipv4=149.248.52.240 :loc=ca.on ) ( inet:ipv4=49.51.12.195 :loc=ca.on.barrie ) ( inet:ipv4=199.201.123.200 :loc=ca.on.keswick ) ]
.. storm-cli:: inet:ipv4:loc ^= ca.on

.. NOTE::
  
  Specifying a more granular prefix value will not match values that are less granular. That is, ``inet:ipv4:loc ^= ca.on``
  will fail to match ``inet:ipv4:loc = ca``.


Equals Operator
~~~~~~~~~~~~~~~

When **lifting** or **filtering** on ``loc`` property values using the equals operator ( ``=`` ), Synapse will return **exact** matches for
the specified value. The query below will only lift ``geo:place`` nodes with ``:loc = us.wa.seattle``; it will not lift nodes with ``:loc = us.wa``
or ``:loc = us.washington.seattle``:

Lift all places in the city of Seattle, Washington:

.. storm-pre:: [ ( geo:place=* :name='space needle' :loc=us.wa.seattle :latlong=(47.6205099,-122.3514714) ) ( geo:place=* :name='seattle-tacoma international airport' :loc=us.wa.seattle :latlong=(47.4502535,-122.3110105) ) ]
.. storm-cli:: geo:place:loc = us.wa.seattle

When **lifting** on ``:loc`` property values using the equals operator ( ``=`` ), a single asterisk ( ``*`` ) can be used
as a "wildcard" to represent any trailing string following a dot boundary (including no trailing string  - ``:loc = us.*``
will match ``:loc = us`` as well as ``:loc = us.tx.austin``). The asterisk must immediately follow a dot boundary and must
be the final character in the expression (e.g., expressions such as ``:loc = us.*.rochester`` and ``:loc = us.m*`` are
invalid; the expressions will not generate an error but will fail to return any nodes).

Lift all organizations located in Turkey:

.. storm-cli:: ou:org:loc = tr.*

Lift all IP addresses geolocated in the province of Ontario, Canada:

.. storm-cli:: inet:ipv4:loc = ca.on.*

.. NOTE::

  Lifting by ``loc`` property value using the wildcard is equivalent to a prefix lift. The following queries will
  return the same results:
  
  Wildcard: ``ou:org:loc = de.*``
  
  Prefix match: ``ou:org:loc ^= de``


.. _type-str:

str
---

Indexing
++++++++

String (and string-derived) types are indexed by **prefix** (character-by-character from the beginning of the
string). This allows matching on any initial substring.

Parsing
+++++++

Some string types and string-derived types are normalized to all lowercase to facilitate pivoting across like
values without case-sensitivity. For types that are normalized in this fashion, the string can be entered in
mixed-case and will be automatically converted to lowercase.

Strings are subject to Synapse’s restrictions regarding using :ref:`storm-whitespace-literals`.

Insertion
+++++++++

Same as for parsing.

Operations
++++++++++

Because of Synapse’s use of **prefix indexing,** string and string-derived types can be lifted or filtered
based on matching an initial substring of any string using the prefix extended comparator (``^=``)
(see :ref:`lift-prefix` and :ref:`filter-prefix`).

Prefix matching is case-sensitive based on the specific type being matched. If the target property’s type is
case-sensitive, the string to match must be entered in case-sensitive form. If the target property is 
case-insensitive (i.e., normalized to lowercase) the string to match can be entered in any case (upper, lower,
or mixed) and will be automatically normalized by Synapse.

**Examples**

Lift all organizations whose name starts with the word "Acme ":


.. storm-cli:: ou:org:name^='acme '

Filter a set of Internet accounts to those with usernames starting with 'matrix':

.. storm-pre:: [ inet:web:acct=(twitter.com,matrixmaster) inet:web:acct=(twitter.com,matrixneo) ]
.. storm-cli:: inet:web:acct:site=twitter.com +:user^=matrix


Strings and string-derived types can also be lifted or filtered using the regular expression extended comparator
( ``~=``) (see :ref:`lift-regex` and :ref:`filter-regex`).

.. _type-syn-tag:

syn:\tag
--------

``syn:tag`` is a specialized type used for :ref:`data-tag` nodes and properties within Synapse. Tags are used
to group related nodes; provide context to nodes; and often represent domain-specific, analytically relevant
observations or assessments. Tags support a hierarchical namespace based on user-defined dot-separated strings.
This hierarchy allows recording classes or categories of observations that can be defined with increasing specificity.
(See :ref:`analytical-model` for more information.)


Indexing
++++++++

The ``syn:tag`` type is an extension of the :ref:`type-str` type and is **prefix-indexed** like other strings.

``syn:tag`` values are normalized to lowercase.

Parsing
+++++++

Components of a ``syn:tag`` value must be separated by the dot ( ``.`` ) character. The dot is a reserved character
for the ``syn:tag`` type and is used to separate string elements along hierarchical boundaries. A ``syn:tag`` value
that consists of a single element does not require a trailing dot.

``syn:tag`` values can contain ASCII lowercase characters, numerals, and underscores, as well as Unicode words
(including most characters that can be part of a word in any language). Spaces and ASCII symbols (other than the
underscore) are not allowed.

The following are all acceptable ``syn:tag`` values:

- ``syn:tag = cno``
- ``syn:tag = rep.vt.exploit``
- ``syn:tag = rep.microsoft.forest_blizzard``
- ``syn:tag = 总参.三部``

When creating a ``syn:tag`` node or setting a property whose type is ``syn:tag`` (such as ``risk:threat:tag``),
Synapse will automatically normalize the value by:

- converting uppercase letters to lowercase;
- converting dashes ( ``-`` ) or spaces to underscores ( ``_`` ).
- ignoring any disallowed characters.

**Examples:**

.. storm-cli:: [ syn:tag = "rep.us-cisa.LAPSUS$" ]

In the above example:

- the dash in ``us-cisa`` is converted to an underscore;
- ``LAPSUS`` is lowercased to ``lapsus``; and
- the dollar sign ( ``$`` ) is ignored.

.. NOTE::
   
   If you attempt to **apply** a tag that contains invalid characters to a node, Synapse will throw a Storm syntax
   error. The only normalization Synapse performs in this situation is to gracefully convert any uppercase letters
   to lowercase. The following Storm query will throw an error:
   
   ``[ inet:fqdn = woot.com +#rep.us-cisa.LAPSUS$ ]``


Insertion
+++++++++

``syn:tag`` are unique in that they are a type that can also be applied as a label to other nodes.

A ``syn:tag`` (as a node) does not have to be created before the equivalent tag (label) can be applied to another
node. That is, applying a tag to a node will result in the automatic creation of the corresponding ``syn:tag``
node or nodes (assuming the appropriate user permissions). For example:

.. storm-cli:: [ inet:fqdn = woot.com +#some.new.tag ]

The Storm syntax above will apply the tag ``#some.new.tag`` to the node ``inet:fqdn = woot.com`` and automatically
create the node ``syn:tag = some.new.tag`` if it does not already exist (as well as ``syn:tag = some`` and
``syn:tag = some.new``).


Operations
+++++++++++

Like strings and other string-derived types, ``syn:tag`` types are **prefix-indexed**. This means that ``syn:tag``
values can be lifted and filtered using the prefix comparison operator ( ``^=`` ).

When lifting and filtering ``syn:tag`` types by prefix, the expression to match is **not** constrained by the
dot ( ``.`` ) boundary that separates tag elements.

Prefix comparison for ``syn:tag`` types is useful because it allows you to easily identify a subset of tags
or to lift / filter tags at any appropriate level of resolution within a tag hierarchy.

**Examples:**

Lift all tags in the computer network operations (``cno``) tree:

.. storm-pre:: [ syn:tag=cno.threat.t27 syn:tag=cno.mal.redtree ]
.. storm-cli:: syn:tag ^= cno

Lift all threats (``risk:threat`` nodes) whose ``:tag`` value is associated with Dell Secureworks threats
whose name begins with "br":

.. storm-pre:: [ (risk:threat=* :org:name='bronze elgin' :reporter:name=secureworks :tag=rep.secureworks.bronze_elgin) (risk:threat=* :org:name='bronze president' :reporter:name=secureworks :tag=rep.secureworks.bronze_president) ]
.. storm-cli:: risk:threat:tag ^=rep.secureworks.br

**Usage notes:**

- Specifying a more granular prefix value will **not** match values that are less granular. That is, ``syn:tag^=cno.infra``
  will fail to match ``syn:tag = cno``.

- Use of the equals comparator ( ``=`` ) with ``syn:tag`` types will match the **exact value only.** So
  ``syn:tag = rep`` will **only** match that tag and will not match ``syn:tag = rep.symantec`` or
  ``syn:tag = rep.trend.pawnstorm``.

- When lifting or filtering ``syn:tag`` types, use of the wildcard ( ``*`` ) is not allowed. For example,
  the following Storm expression is invalid and will throw a syntax error: ``syn:tag = rep.*.cobalt_strike``

.. NOTE::
  
  Working with (lifting, filtering, etc.) ``syn:tag`` **types** (``syn:tag`` forms or property values)
  is different from working with **tags** applied to nodes. In particular, when filtering based on the
  tag(s) applied to a set of nodes, you can filter using single or double asterisks ( ``*`` or ``**``).
  See :ref:`filter-tag-globs` or the general :ref:`tag-filter` or :ref:`tag-lifts` sections for details
  on working with tags applied to nodes.


.. _type-taxoxnomy:

taxonomy
--------

A ``taxonomy`` in Synapse is used to represent a set of hierarchical types or categories that can be used to classify
objects (forms). Many forms in Synapse include ``:type`` properties (such as ``risk:tool:software:type``, ``geo:place:type``,
or ``media:news:type``).

.. TIP::
  
  ``taxonomy`` is a base :ref:`gloss-type` that is commonly extended to define form-specific taxonomies. That is, a tool
  (``risk:tool:software``) has a ``:type`` property that can represent a set of tool/malware types or categories. The
  ``risk:tool:software:type`` property has a form-specific type of ``risk:tool:software:taxonomy``.
  
  While this section describes the behavior of taxonomies generally, keep in mind that each form can have its own taxonomy /
  set of categories independent of other taxonomies. This allows you to define one taxonomy to categorize tools/malware and
  a separate taxonomy to categorize articles or publications, for example.

Most taxonomy types are also forms (i.e., ``risk:tool:software:taxonomy``), so you can lift, view, and work with them
just like other nodes in Synapse. To ensure consistency across the numerous taxonomy forms, most taxonomies inherit the
``meta:taxonomy`` :ref:`gloss-interface`.

Given their hierarchical structure, taxonomies share some similarities with `tags`_:

- Taxonomies can be hierarchical, using a dotted (dot-separated) namespace to represent various levels in the hierarchy.
- Taxonomy forms include properties such as ``:base``, ``:depth``, and ``:parent`` that allow you to lift,
  pivot, and navigate among taxonomy nodes similar to the way you navigate :ref:`analytical-tags-nodes`.

There are no "pre-defined" taxonomies in Synapse. You can make use of taxonomies (or not), and can define taxonomies that
are tailored to your specifc analysis needs. For example, you can construct a multi-level taxonomy to help subdivide and
organize industries using their ``:type`` property:

- ``ou:industry:type = education``
- ``ou:industry:type = education.colleges``
- ``ou:industry:type = education.colleges.universities``
- ``ou:industry:type = education.colleges.junior``
- ``ou:industry:type = finance``
- ``ou:industry:type = finance.banking``
- ``ou:industry:type = finance.defi``

...etc.

Taxonomies do not have to be multi-level / hierarchcial. If you only need a simple set of categories, you can define a
flat taxonomy with only one level. The following uses a flat taxonomy to populate ``risk:tool:software:type`` properties:

- ``risk:tool:software:type = backdoor``
- ``risk:tool:software:type = downloader``
- ``risk:tool:software:type = dropper``
- ``risk:tool:software:type = utility``

... etc.


Indexing
++++++++

The ``taxonomy`` type is an extension of the :ref:`type-str` type and is **prefix-indexed** like other strings.

``taxonomy`` values are normalized to lowercase. A ``taxonomy`` value always includes a trailing dot ( ``.`` ),
regardless of the number of elements (taxons) in the value.

The trailing dot is masked / omitted when displaying the taxonomy value. This difference can be seen when
displaying the value's representation (display value, using the method ``$node.repr()``) as opposed to its actual
value (using the method ``$node.value()``):

.. storm-pre:: [ ou:goal:type:taxonomy=financial_gain ]
.. storm-cli:: ou:goal:type:taxonomy=financial_gain $lib.print($node.repr()) $lib.print($node.value())


Parsing
+++++++

Components of a ``taxonomy`` value must be separated by the dot ( ``.`` ) character. The dot is a reserved character
for the ``taxonomy`` type and is used to separate elements (taxons) along hierarchical boundaries. All ``taxonomy``
values end in a trailing dot.

``taxonomy`` values can contain ASCII lowercase characters, numerals, and underscores, as well as Unicode words
(including most characters that can be part of a word in any language). Spaces and ASCII symbols (other than the
underscore) are not allowed.

When creating a ``taxonomy`` node or setting a ``taxonomy`` property, Synapse will automatically normalize the value by:

- converting uppercase letters to lowercase;
- converting dashes ( ``-`` ) or spaces to underscores ( ``_`` );
- ignoring any disallowed characters; and
- adding the trailing dot (  ``.`` ) to the stored value if not specified.


Insertion
+++++++++

N/A - no special behavior when working with ``taxonomy`` nodes or properties other than as specified above.


Operations
++++++++++

Like strings and other string-derived types, ``taxonomy`` types are **prefix-indexed**. This means that
``taxonomy`` values can be lifted and filtered using the prefix comparison operator ( ``^=`` ).

When lifting and filtering ``taxonomy`` types by prefix, the expression to match is **not** constrained by
the dot ( ``.`` ) boundary that separates taxonomy elements.

Prefix comparison for ``taxonomy`` types is useful because it allows you to easily identify a subset of
forms based on lifting or filtering those forms using any appropriate level of resolution within the
form's taxonomy.

**Examples:**

Lift all industries (``ou:industry`` nodes) within the "media" catetgory / taxonomy:

.. storm-pre:: [ (ou:industry=* :name=media :type=media) (ou:industry=* :name='journalism and news media' :type=media.journalism) (ou:industry=* :name='journalists and reporters' :type=media.journalism.reporters) (ou:industry=* :name=publishing :type=media.publishing) (ou:industry=* :name='print media' :type=media.publishing.print) (ou:industry=* :name=entertainment :type=media.entertainment) ]
.. storm-cli:: ou:industry:type ^= media

Lift all industries (``ou:industry`` nodes) within the "media" catetgory / taxonomy whose subcategory starts
with "j":

.. storm-cli:: ou:industry:type ^= media.j


**Usage notes:**

- Specifying a more granular prefix value will not match values that are less granular. That is,
  ``risk:tool:software:availability ^= public.commercial`` will fail to match ``risk:tool:software:availability = public``

- Use of the equals comparator ( ``=`` ) with ``taxonomy`` types will match the exact value only. So
  ``ou:industry:type = energy`` will only match that taxonomy and will not match ``ou:industry:type = energy.electricity``
  or ``ou:industry:type = energy.electricity.distribution``.

- When lifting or filtering ``taxonomy`` types, use of the wildcard ( ``*`` ) is not allowed. For example, the following
  Storm expression is invalid and will throw a syntax error: ``risk:attacktype = phishing.*``.


.. _type-time:

time
----

Synapse stores ``time`` types in Epoch milliseconds (millis) - that is, the number of milliseconds since 
January 1, 1970. The ``time`` type is technically a date/time because it encompasses both a date and a time.
A time value alone, such as 12:37 PM (12:37:00.000), is invalid.

See also the section on :ref:`type-ival` (interval) types for details on how ``time`` types are used as 
minimum / maximum pairs.

Indexing
++++++++

N/A

Parsing
+++++++

``time`` values can be input into Storm as any of the following:

- **Explicit** times:

  - Human-readable (YYYY/MM/DD hh:mm:ss.mmm):
  
    ``"2018/12/16 09:37:52.324"``
  
  - Human-readable "Zulu" (YYYY/MM/DDThh:mm:ss.mmmZ):
  
    ``2018/12/16T09:37:52.324Z``
    
  - Human-readable with time zone (YYYY-MM-DD hh:mm:ss.mmm+/-hh:mm). No spaces are allowed between the time value
    and the time zone offset:
  
    ``2018-12-16 09:37:52.324-04:00``
    
    .. NOTE::
      
      Synapse does not support the **storage** of an explicit time zone with a time value (i.e., +0800). Synapse
      stores time values in UTC for consistency. If a time zone is specified using an acceptable time zone offset
      format on input, Synapse will automatically convert the value to UTC for storage. If no time zone is specified,
      Synapse will assume the value is in UTC.

  - No formatting (YYYYMMDDhhmmssmmm):
    
    ``20181216093752324``
  
  - Epoch millis:
    
    ``(1544953072324)``
    
    .. TIP::
      
      Synapse expects that users will generally enter time values using "human friendly" strings, and will attempt
      to parse the input as such. Using parentheses tells Synapse to interpret the value as a raw integer.
      
      Note that this parentheses syntax only applies when setting or updating a ``time`` property using Storm.
      When setting or updating a property in the `Optic UI`_ by editing a field, you must enter a time string value.


- **Relative** (offset) time values in the format:
  
  **+** | **-** | **+-** *<count>* *<unit>*
  
  where *<count>* is a numeric value and *<unit>* is one of the following:
    
    - ``minute(s)``
    - ``hour(s)``
    - ``day(s)``
  
  **Examples:**
    
    - ``"+7 days"``
    - ``"-15 minutes"``
    - ``"+-1 hour"``
  
- **"Special"** time values:
  
  - the keyword ``now`` is used to represent the current date/time.
  - a question mark ( ``?`` ) is used to effectively represent an unspecified / indefinite time in the future
    (technically equivalent to 9223372036854775807 millis, i.e., "some really high value that is probably the
    heat death of the universe". Note that technically the largest valid millis value is 9999999999999 
    (thirteen 9’s), which represents 2286/11/20 09:46:39.999).
    
    The question mark can be used as the maximum value of an interval (:ref:`type-ival`) type to specify that 
    the data or assessment associated with the ``ival`` should be considered valid indefinitely. (Contrast that
    with a maximum interval value set to the equivalent of ``now`` that would need to be continually updated over
    time in order to remain current.)

Standard rules regarding using :ref:`storm-whitespace-literals` apply. For example, ``"2018/12/16 09:37:52.324"``
needs to be entered in single or double quotes, but ``2018/12/16`` does not. Similarly, relative times starting
with ``+`` or ``-`` and the special time value ``?`` need to be placed in single or double quotes.

Lower Resolution Time Values and Wildcard Time Values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``time`` values (including tag timestamps) must be entered at a minimum resolution of year (``YYYY``) and can
be entered up to a maximum resolution of milliseconds (``YYYY/MM/DD hh:mm:ss.mmm``).

Where lower resolution values are entered, Synapse will make logical assumptions about the intended date / time
value and zero-fill the remainder of the equivalent epoch mills date / time. For example:

- A value of ``2016`` will be interpreted as 12:00 AM on January 1, 2016 (``2016/01/01 00:00:00.000``).
- A value of ``2018/10/27`` will be interpreted as 12:00 AM on that date (``2018/10/27 00:00:00.000``).
- A value of ``"2020/03/16 05"`` will be interpreted as 05:00 AM on that date (``2020/03/16 05:00:00.000``).
- A value of ``"2018/10/27 14:00-04:00"`` will be interpreted as 14:00 (2:00 PM) on that date with a 4 hour
  offset from UTC (``2018/10/27 14:00:00.000-04:00``, stored in UTC as ``2018/10/27 18:00:00.000``).

Synapse also supports the use of the wildcard ( ``*`` ) character to specify a partial time value match:

- A value of ``2016*`` will be interpreted as "any date / time within the year 2016".
- A value of ``2018/10/27*`` will be interpreted as "any time on October 27, 2018".
- A value of ``"2020/03/16 05*"`` will be interpreted as "any time within the hour of 05:00 on March 16, 2020".

.. NOTE::
  
  When using wildcard syntax, the wildcard must be used on a sensible time value boundary, such as ``YYYYMM*``.
  You cannot us a wildcard to "split" values (i.e., ``YYMMD*`` is invaild syntax).


**Examples:**

Set the time of a DNS request to the current time:

.. storm-cli:: [ inet:dns:request="*" :query:name=woot.com :time=now ]


Set the observed time window (technically an ``ival`` type) for when an IP address was a known sinkhole (via
the ``#cno.infra.dns.sink.hole`` tag) from its known start date to an indefinite future time (i.e., the sinkhole
is presumed to remain a sinkhole indefinitely / until the values are manually updated with an explicit end date):

.. storm-cli:: [ inet:ipv4=1.2.3.4 +#cno.infra.dns.sink.hole=(2017/06/13, "?") ]


- Set the observed time window using a time zone offset:

.. storm-cli:: [ inet:ipv4=5.6.7.8 +#cno.infra.dns.sink.hole=(2017/06/13 09:46+04:00, "?") ]


Insertion
+++++++++

When adding or modifying ``time`` types, any of the above formats (explicit / relative / special terms) can
be specified.

In addition, when adding or modifying ``time`` types, a lower resolution time and a wildcard time behave
identically. In other words, the following are equivalent Storm queries (both will set the ``:time`` value
of the newly created DNS request node to ``2021/01/23 00:00:00.000``):

.. storm-pre:: [ inet:dns:request="*" :time=2021/01/23 ]
.. storm-pre:: [ inet:dns:request="*" :time=2021/01/23* ]

::
  
  [ inet:dns:request="*" :time=2021/01/23 ]
  
  [ inet:dns:request="*" :time=2021/01/23* ]


When specifying a relative time for a ``time`` value, **the offset will be calculated from the current time**
(``now``):

.. storm-cli:: [ inet:dns:request="*" :query:name=woot.com :time="-5 minutes" ]

Plus / minus ( ``+-`` ) relative times cannot be specified for ``time`` types, as the type requires a single
value.  See the section on :ref:`type-ival` (interval) types for details on using ``+-`` times with ``ival``
types.

Operations
++++++++++

``time`` types can be lifted and filtered using:

 - Standard logical and mathematical comparison operators (comparators).
 - The extended range ( ``*range=`` ) custom comparator.
 - The extended interval ( ``@=`` ) custom comparator.


Standard Operators
~~~~~~~~~~~~~~~~~~

``time`` types can be lifted and filtered with the standard logical and mathematical comparators (see 
:ref:`storm-ref-lift` and :ref:`storm-ref-filter`). This includes the use of lower resolution time values and
wildcard time values.

**Example:**

Downselect a set of DNS request nodes to those that occurred prior to June 1, 2019:


.. storm-pre:: [ ( inet:dns:request=* :query:name=hurr.com :time='2018/06/28 17:43' ) ( inet:dns:request=* :query:name=derp.net :time='2015/12/14 19:22' ) ]
.. storm-cli:: inet:dns:request +:time<2019/06/01

.. NOTE::
  
  It is important to understand the differences in behavior when lifting and filtering ``time`` types using
  lower resolution time values (which Synpase zero-fills) or wildcard time values (which Synpase wildcard-matches).
  These behaviors vary based on the specific operator used.

- When lifting or filtering using the equivalent ( ``=`` ) operator, behavior is **different:**
  
  - ``:time=2021/05/13`` means equal to **the exact date/time value** ``2021/05/13 00:00:00.000``.
  - ``:time=2021/05/13*`` means equal to **any** time on that date (``2021/05/13 00:00:00.000`` through
    ``2021/05/13 23:59:59.999``).

- When lifting or filtering using the greater than ( ``>``) / greater than or equal to ( ``>=``) operators,
  behavior is **equivalent:**
  
  - ``:time>2021/05/13`` and ``:time>2021/05/13*`` **both** mean any date / time greater than ``2021/05/13 00:00:00.000``.
  - ``:time>=2021/05/13`` and ``:time>=2021/05/13*`` **both** mean any date / time greater than or equal to
    ``2021/05/13 00:00:00.000``.
  
  Both are equivalent because in this case Synapse interprets the wildcard syntax as "greater than or equal to
  the **lowest** possible wildcard match", which in this case is ``2021/05/13 00:00:00.000``.

- When lifting or filtering using the less than ( ``<`` ) / less than or equal to ( ``<=`` ) operators, behavior
  is **different:**
  
  - ``:time<2021/05/13`` / ``:time<=2021/05/13`` mean any date / time less than (or less than or equal to)
    ``2021/05/13 00:00:00.000``.
  - ``:time<2021/05/13*`` / ``:time<=2021/05/13*`` both mean any date / time less than (or less than or equal
    to) ``2021/05/13 23:59:59.999``.
  
  The behavior differs because in this case Synapse interprets the wildcard syntax as "less than or equal to the
  **highest** possible wildcard match", which in this case is ``2021/05/13 23:59:59.999``.

.. TIP::
  
  The wildcard syntax is useful because it can provide a simplified, more intuitive means to specify certain time
  ranges / time intervals without needing to use the range ( ``*range=`` ) or interval ( ``@=`` ) operators. For
  example, the following three Storm queries are equivalent and will return all files compiled at any time within
  the year 2019:
  
  ::
    
    file:bytes:mime:pe:compiled=2019*
    
    file:bytes:mime:pe:compiled*range=('2019/01/01 00:00:00.000', '2019/12/31 23:59:59.999')
    
    file:bytes:mime:pe:compiled@=('2019/01/01', '2020/01/01')
  
  (A **range** maximum value represents "less than or equal to" that value, while an **interval** maximum value
  represents "less than" that value.)


Range Custom Operator
~~~~~~~~~~~~~~~~~~~~~

``time`` types can lifted and filtered using the ``*range=`` custom comparator (see :ref:`lift-range` and 
:ref:`filter-range`).

**Example:**

Lift a set of ``file:bytes`` nodes whose PE compiled time is between January 1, 2019 and today:


.. storm-pre:: [ ( file:bytes=sha256:9f9d96e99cef99cbfe8d02899919a7f7220f2273bb36a084642f492dd3e473da :mime:pe:compiled='2019/10/07 12:42:45' ) ( file:bytes=sha256:bd422f912affcf6d0830c13834251634c8b55b5a161c1084deae1f9b5d6830ce :mime:pe:compiled='2021/04/13 00:23:14' ) ]
.. storm-cli:: file:bytes:mime:pe:compiled*range=(2019/01/01, now)

.. NOTE::
  
  Both lower resolution times and wildcard times can be used for values specified within the ``*range=`` operator.
  Because the range operator is a shorthand syntax for "greater than or equal to `<range_min>` and less than or
  equal to `<range_max>`", users should be aware of differences in behavior between each kind of time value with
  greater than / less than operators.
  
See the Storm documents referenced above for additional examples using the range (``*range=``) comparator.


Interval Custom Operator
~~~~~~~~~~~~~~~~~~~~~~~~

``time`` types can be lifted and filtered using the interval ( ``@=`` ) custom comparator (see :ref:`lift-interval`
and :ref:`filter-interval`). The comparator is specifically designed to compare ``time`` types and ``ival`` types,
which can be useful (for example) for filtering to a set of nodes whose ``time`` properties fall within a specified
interval.

**Example:**

Lift a set of DNS A records whose window of observation includes March 16, 2019 at 13:00 UTC:


.. storm-pre:: [ ( inet:dns:a=(aaaa.org,1.2.3.4) .seen=('2018/12/29 12:36:27','2019/06/03 18:14:33') ) ( inet:dns:a=(bbbb.edu,5.6.7.8) .seen=('2019/03/16 12:59:59','2019/03/16 13:01:01') ) ]
.. storm-cli:: inet:dns:a.seen@='2019/03/16 13:00'

.. NOTE::
  
  Both lower resolution times and wildcard time can be used for values specified within the ``@=`` operator.
  Because the interval operator is a shorthand syntax for "greater than or equal to `<ival_min>` and less than
  `<ival_max>`", users should be aware of differences in behavior between each kind of time value with greater
  than / less than operators.

See the Storm documents referenced above for additional examples using the interval (``@=``) comparator.

.. _types: https://synapse.docs.vertex.link/en/latest/synapse/glossary.html#type
.. _documentation: ../autodocs/datamodel_types.html
.. _code: https://github.com/vertexproject/synapse
.. _Optic UI: https://synapse.docs.vertex.link/projects/optic/en/latest/index.html
.. _Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/guiddef/ns-guiddef-guid
.. _variables: https://synapse.docs.vertex.link/en/latest/synapse/userguides/storm_adv_vars.html
.. _tags: https://synapse.docs.vertex.link/en/latest/synapse/userguides/storm_ref_type_specific.html#syn-tag

