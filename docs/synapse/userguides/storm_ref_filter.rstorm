.. highlight:: none

.. storm-cortex:: default
.. storm-pre:: $propinfo = $lib.dict(doc="The VirusTotal reputation score.") $lib.model.ext.addFormProp(file:bytes, _virustotal:reputation, (int, $lib.dict()), $propinfo)
.. storm-pre:: $propinfo = $lib.dict(doc="Boolean which records whether the organization is a threat group.") $lib.model.ext.addFormProp(ou:org, _vertex:threatintel:isthreat, (bool, $lib.dict()), $propinfo)
.. storm-pre:: $tagpropinfo = $lib.dict(doc="A risk tagprop.") $lib.model.ext.addTagProp(risk, (int, $lib.dict()), $tagpropinfo)

.. _storm-ref-filter:

Storm Reference - Filtering
===========================

Filter operations are performed on the output of a previous Storm operation such as a lift or pivot.
A filter operation downselects from the working set of nodes by either including or excluding a subset
of nodes based on a set of criteria.

- ``+`` specifies an **inclusion** filter. The filter downselects the working set to **only** those
  nodes that match the specified criteria.
- ``-`` specifies an **exclusion** filter. The filter downselects the working set to all nodes **except**
  those that match the specified criteria.

Similar to lift operations (:ref:`storm-ref-lift`), filter operations can be broken down into "types" of
filters based on the criteria, comparison operator, or special handler used:

- `Filter by Form`_
- `Filter by Property`_
- `Filter by Property Value - Standard Comparison Operators`_
- `Filter by Property Value - Extended Comparison Operators`_
- `Filter by Tags`_

.. TIP::
  
  In most cases, you can filter using the same criteria used for lifts.

Storm also supports additional types of filters and filter operations:

- `Compound Filters`_
- `Subquery Filters`_
- `Expression Filters`_
- `Embedded Property Syntax`_

See :ref:`storm-ref-syntax` for an explanation of the syntax format used below.

See :ref:`storm-ref-type-specific` for details on special syntax or handling for specific data types.


.. _filter-form:

Filter by Form
--------------

A "filter by form" operation modifies your working set to include (or exclude) all nodes of the specified form.

**Syntax:**

*<query>* **+ | -** *<form>*

**Examples:**

*Filter the current working set to only include domains (inet:fqdn nodes):*

.. storm-pre:: [ inet:fqdn=woot.com inet:fqdn=vertex.link  inet:fqdn=google.com inet:ipv4=127.0.0.1 ] +inet:fqdn
::
  
  <query> +inet:fqdn

*Filter the current working set to exclude URLs (inet:url nodes):*

.. storm-pre:: [ inet:fqdn=vertex.link inet:url=https://vertex.link ] -inet:url
::
  
  <query> -inet:url


.. _filter-prop:

Filter by Property
------------------

A "filter by property" operation modifies your working set to include (or exclude) all forms that **have**
the specified property (secondary, universal, or extended), regardless of the property value.

.. TIP::
  
  When filtering by property, you can specify the property using either the **full** property name (i.e.,
  the combined form and property, such as ``inet:dns:a:ipv4``) or the **relative** property name (i.e.,
  the property name alone, including its separator character, such as ``:ipv4``).
  
  Using the relative property name allows for simplified syntax and more efficient data entry ("less
  typing"). Full property names can be used for clarity (i.e., specifying **exactly** what you want to
  filter on).
  
  Full property names may be **required** in cases where multiple nodes in the inbound working set have
  the same relative property name (e.g., ``inet:dns:a:ipv4`` and ``inet:url:ipv4``) and you only wish to
  filter based on the property of one of the forms.
  
  Each example below is shown using both the full property name (*<form>:<prop>*) and the relative
  property name (*:<prop>*).


.. _filter-prop-second:

Filter by Secondary Property
++++++++++++++++++++++++++++

**Syntax:**

*<query>* **+ | -** [ *<form>* ] **:** *<prop>*

**Examples:**

*Filter the current working set to only include threats (risk:threat nodes) that have an assessed country of origin:*

.. storm-pre:: [ (risk:threat=* :org:name=unc1234 ) (risk:threat=* :org:name='peach sandstorm' :country:code=ir) (risk:threat=* :org:name='bronze butler' :country:code=cn) ] +risk:threat:country:code
::
  
  <query> +risk:threat:country:code

.. storm-pre:: [ (risk:threat=* :org:name=unc1234 ) (risk:threat=* :org:name='peach sandstorm' :country:code=ir) (risk:threat=* :org:name='bronze butler' :country:code=cn) ] +:country:code
::
  
  <query> +:country:code


*Filter the current working set to exclude articles (media:news nodes) that have a publisher name:*

.. storm-pre:: [ (media:news=* :publisher:name=microsoft) (media:news=* :publisher:name=eset) (media:news=* ) ] -media:news:publisher:name
::
  
  <query> -media:news:publisher:name

.. storm-pre:: media:news -:publisher:name=mitre
::
  
  <query> -:publisher:name
  

.. _filter-prop-univ:

Filter by Universal Property
++++++++++++++++++++++++++++

**Syntax:**

*<query>* **+ | -** [ *<form>* ] **.** *<prop>*

**Example:**

*Filter the current working set to only include DNS A records (inet:dns:a nodes) tthat have a .seen property:*

.. storm-pre:: [ (inet:dns:a=(vertex.link,1.1.1.1) .seen=('2016/06/01 12:22:47.234', '2017/06/10 02:44:55.437')) (inet:dns:a=(vertex.link,2.2.2.2)) ] +inet:dns:a.seen
::
  
  <query> +inet:dns:a.seen

.. storm-pre:: [ (inet:dns:a=(vertex.link,1.1.1.1) .seen=(2016/06/01,2020/06/01)) (inet:dns:a=(vertex.link,2.2.2.2)) ] +.seen
::
  
  <query> +.seen


.. _filter-prop-extend
  
Filter by Extended Property
+++++++++++++++++++++++++++

**Syntax:**

*<query>* **+ | -** [ *<form>* ] **:_** *<prop>*

**Example:**

*Filter the current working set to exclude those organizations (ou:org nodes) that have an "isthreat" extended property:*

.. storm-pre:: [ ( ou:org=* :name=vertex :_vertex:threatintel:isthreat=0 ) ( ou:org=* :name=fsb :_vertex:threatintel:isthreat=1 ) ] -ou:org:_vertex:threatintel:isthreat
::
  
  <query> -ou:org:_vertex:threatintel:isthreat

.. storm-pre:: [ ( ou:org=* :name=vertex :_vertex:threatintel:isthreat=0 ) ( ou:org=* :name=fsb :_vertex:threatintel:isthreat=1 ) ] -:_vertex:threatintel:isthreat
::
  
  <query> -:_vertex:threatintel:isthreat

.. TIP::
  
  The ``:_vertex:threatintel:isthreat`` extended property is a Boolean property added by the `Vertex-Threat-Intel`_
  Power-Up. It can be used to indicate whether an organization is tracked as a threat group.


.. filter-prop-standard:

Filter by Property Value - Standard Comparison Operators
--------------------------------------------------------

A "filter by property value" operation modifies the current working set to include (or exclude) the node(s) whose
property matches the specified value. This type of filter requires:

- the filter operator ( ``+`` or ``-`` );
- the property name (full or relative) to use for the filter;
- a :ref:`gloss-comp-operator` to specify how the property value should be evaluated; and
- the property value.

A "filter by property value" can be performed using primary, secondary, universal, or extended properties.

In Synapse, we define **standard comparison operators** as the following set of operators:

- equal to ( ``=`` )
- less than ( ``<`` )
- greater than ( ``>`` )
- less than or equal to ( ``<=`` )
- greater than or equal to ( ``>=`` )

For filter operations, the not equal ( ``!=`` ) operator is also supported.

When filtering by secondary, universal, or extended property value, you can specify the property using
either the **full** property name (i.e., the combined form and property, such as ``inet:dns:a:ipv4``)
or the **relative** property name (i.e., the property name alone, including its separator character,
such as ``:ipv4``).

Using the relative property name allows for simplified syntax and more efficient data entry ("less
typing"). Full property names can be used for clarity (i.e., specifying **exactly** what you want to
filter on).

Full property names may be **required** in cases where multiple nodes in the inbound working set have
the same relative property name (e.g., ``inet:dns:a:ipv4`` and ``inet:url:ipv4``) and you only wish to
filter based on the property of one of the forms.

Each example below is shown using both the full property name (*<form>:<prop>*) and the relative
property name (*:<prop>*).

.. TIP::
  
  When filtering nodes by a property value where the value is a time (date / time), you do not need to
  use full ``YYYY/MM/DD hh:mm:ss.mmm`` syntax. Synapse allows you to use either lower resolution
  values (e.g., ``YYYY/MM/DD``) or wildcard values (e.g., ``YYYY/MM*``). In particular, wildcard syntax
  can be used to specify any values that match the wildcard expression. See the type-specific documentation
  for :ref:`type-time` types for a detailed discussion of these behaviors.


.. _filter-prop-std-primary:

Filter by Primary Property Value
++++++++++++++++++++++++++++++++

**Syntax:**

*<query>* **+ | -** *<form>* *<operator>* *<valu>*


*Filter the current working set to exclude the loopback IPv4 address (127.0.0.1):*

.. storm-pre:: [ inet:ipv4=127.0.0.1 inet:ipv4=8.8.8.8 ] -inet:ipv4 = 127.0.0.1
::
  
  <query> -inet:ipv4 = 127.0.0.1

.. storm-pre:: [ inet:ipv4=127.0.0.1 inet:ipv4=8.8.8.8 ] +inet:ipv4 != 127.0.0.1
::
  
  <query> +inet:ipv4 != 127.0.0.1


.. _filter-prop-std-secondary:

Filter by Secondary Property Value
++++++++++++++++++++++++++++++++++

**Syntax:**

*<query>* **+ | -** [ *<form>* ] **:** *<prop>* *<operator>* *<pval>*


*Filter the current working set to include only those domains (inet:fqdn nodes) that are also logical zones:*

.. storm-pre:: [ inet:fqdn=woot.com inet:fqdn=vertex.link inet:fqdn=google.com ] +inet:fqdn:iszone = 1
::
  
  <query> +inet:fqdn:iszone = 1


.. storm-pre:: [ inet:fqdn=woot.com inet:fqdn=vertex.link inet:fqdn=google.com ] +:iszone = 1
::
  
  <query> +:iszone  = 1

*Filter the current working set to exclude any files (file:bytes nodes) with a PE compiled time of 1992-06-19 22:22:17:*

.. storm-pre:: [ (file:bytes=sha256:2d168c4020ba0136cd8808934c29bf72cbd85db52f5686ccf84218505ba5552e :mime:pe:compiled="1992/06/19 22:22:17.000") ] -file:bytes:mime:pe:compiled = '1992/06/19 22:22:17'
::
  
  <query> -file:bytes:mime:pe:compiled = '1992/06/19 22:22:17'
  
.. storm-pre:: [ (file:bytes=sha256:2d168c4020ba0136cd8808934c29bf72cbd85db52f5686ccf84218505ba5552e :mime:pe:compiled="1992/06/19 22:22:17.000") ] -:mime:pe:compiled = '1992/06/19 22:22:17'
::
  
  <query> -:mime:pe:compiled = '1992/06/19 22:22:17'


*Filter the current working set to include only those files (file:bytes nodes) compiled in 2019:*

.. storm-pre:: [ (file:bytes=sha256:9f9d96e99cef99cbfe8d02899919a7f7220f2273bb36a084642f492dd3e473da :mime:pe:compiled='2019/03/14 11:14:00.000') ] +file:bytes:mime:pe:compiled = 2019*
::
  
  <query> +file:bytes:mime:pe:compiled = 2019*

.. storm-pre:: [ (file:bytes=sha256:9f9d96e99cef99cbfe8d02899919a7f7220f2273bb36a084642f492dd3e473da :mime:pe:compiled='2019/03/14 11:14:00.000') ] +:mime:pe:compiled = 2019*
::
  
  <query> +:mime:pe:compiled = 2019*


*Filter thet current working set to exclude those files (file:bytes nodes) whose size is greater than or equal to 1MB:*

.. storm-pre:: [ (file:bytes=sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 :size=16384) (file:bytes=sha256:ec04b04e079ff54e73faf7ef72e69b8919fb24eecba521b65788c47eac0baf41 :size=1000054 ) ] -file:bytes:size >= 1000000
::
  
  <query> +file:bytes:size >= 1000000


.. _filter-prop-std-universal

Filter by Universal Property Value
++++++++++++++++++++++++++++++++++

Synapse has two built-in universal properties:

- ``.created`` (a time) which represents the date and time a node was created in Synapse; and
- ``.seen`` (an interval), a pair of date / time values that can optionally be used to represent
  when a node existed or was observed.

Times (date / time values) are stored as integers (epoch milliseconds) in Synapse and can be filtered using any
standard comparison operator.

Because intervals are a pair of date / time values, they can only be filtered using the equal to ( ``=`` )
standard comparison operator.

The :ref:`filter-interval` and :ref:`filter-range` extended comparison operators provide additional flexibility
when filtering by times and intervals.

See also the :ref:`type-time` and :ref:`type-ival` sections of the :ref:`storm-ref-type-specific` guide for
additional details on working with times and intervals in Synapse.

**Syntax:**

**+ | -** [ *<form>* ] **.** *<prop>* *<operator>* *<pval>*

*Filter the current working set to include only those nodes created on January 1, 2024 or later:*

.. storm-pre:: .created +.created >= 2024/01/01
::
  
  <query> +.created >= 2024/01/01


*Filter the current working set to include only those FQDNs (inet:fqdn nodes) created on January 1, 2024 or later:*

.. storm-pre:: .created +inet:fqdn.created >= 2024/01/01
::
  
  <query> +inet:fqdn.created >= 2024/01/01


*Filter the current working set to include only the DNS A records (inet:dns:a nodes) whose .seen property exactly matches the specified interval:*

.. storm-pre:: [ (inet:dns:a=(vertex.link,1.1.1.1) .seen=('2016/06/01 12:22:47.234', '2017/06/10 02:44:55.437')) (inet:dns:a=(vertex.link,2.2.2.2)) ] +inet:dns:a.seen = ('2016/06/01 12:22:47.234', '2017/06/10 02:44:55.437')
::
  
  <query> +inet:dns:a.seen = ('2016/06/01 12:22:47.234', '2017/06/10 02:44:55.437')

.. storm-pre:: [ (inet:dns:a=(vertex.link,1.1.1.1) .seen=('2016/06/01 12:22:47.234', '2017/06/10 02:44:55.437')) (inet:dns:a=(vertex.link,2.2.2.2)) ] +.seen = ('2016/06/01 12:22:47.234', '2017/06/10 02:44:55.437')
::
  
  <query> +.seen = ('2016/06/01 12:22:47.234', '2017/06/10 02:44:55.437')


.. filter-prop-std-extended

Filter by Extended Property Value
+++++++++++++++++++++++++++++++++

When filtering by extended property value, you can use any standard comparison operator supported by the
property's type. For example, if the extended property is a string, only the equal to ( ``=`` ) standard
operator is supported. If the extended property is an integer, any of the standard operators can be used.

**Syntax:**

**+ | -** [ *<form>* ] **:_** *<prop>* *<operator>* *<pval>*

*Filter the current working set to include only those organizations (ou:org nodes) are categorized as threats:*

.. storm-pre:: [ ( ou:org=* :name=vertex :_vertex:threatintel:isthreat=0 ) ( ou:org=* :name=fsb :_vertex:threatintel:isthreat=1 ) ] +ou:org:_vertex:threatintel:isthreat = true
::
  
  <query> +ou:org:_vertex:threatintel:isthreat = true

.. storm-pre:: [ ( ou:org=* :name=vertex :_vertex:threatintel:isthreat=0 ) ( ou:org=* :name=fsb :_vertex:threatintel:isthreat=1 ) ] +:_vertex:threatintel:isthreat = true
::
  
  <query> +:_vertex:threatintel:isthreat = true

.. TIP::
  
  Boolean values can be specified using either ``true`` / ``false`` or ``1`` / ``0``.

*Filter the current working set to incldue only those files whose VirusTotal "reputation" score is less than -100:*

.. storm-pre:: [ file:bytes=sha256:87b7e57140e790b6602c461472ddc07abf66d07a3f534cdf293d4b73922406fe :size=188928 :mime='application/vnd.microsoft.portable-executable' :_virustotal:reputation=-427 ] +file:bytes:_virustotal:reputation < -100
::
  
  <query> +file:bytes:_virustotal:reputation < -100

.. storm-pre:: [ file:bytes=sha256:87b7e57140e790b6602c461472ddc07abf66d07a3f534cdf293d4b73922406fe :size=188928 :mime='application/vnd.microsoft.portable-executable' :_virustotal:reputation=-427 ] +:_virustotal:reputation < -100
::
  
  <query> +:_virustotal:reputation < -100


.. _filter-prop-extended:

Filter by Property Value - Extended Comparison Operators
--------------------------------------------------------

Storm supports a set of extended comparison operators (comparators) for specialized filter operations.
In most cases, the same extended comparators are available for both lifting and filtering:

- `Filter by Regular Expression (~=)`_
- `Filter by Prefix (^=)`_
- `Filter by Time or Interval (@=)`_
- `Filter by Range (*range=)`_
- `Filter by Set Membership (*in=)`_
- `Filter by Proximity (*near=)`_
- `Filter by (Arrays) (*[ ])`_

.. _filter-regex:

Filter by Regular Expression (~=)
+++++++++++++++++++++++++++++++++

The extended comparator ``~=`` is used to filter nodes based on PCRE-compatible regular expressions.

.. TIP::
  
  `Filter by Prefix (^=)`_ can be used to filter based on the beginning of string-based properties.


**Syntax:**

*<query>* **+** | **-** *<form>* **~=** *<regex>*

*<query>* **+** | **-** [ *<form>* ] **:** | **.** | **:_** *<prop>* **~=** *<regex>*

**Examples:**

*Filter the current working set to include only files (file:bytes nodes) with a PDB path containing the string 'tekide':*

.. storm-pre:: [ (file:bytes=sha256:1a287331e2bfb4df9cfe2dab1b77c9b5522e923e52998a2b1934ed8a8e52f3a8 :mime='application/vnd.microsoft.portable-executable' :mime:pe:pdbpath='C:\Users\mr.tekide\Documents\Visual Studio 2013\Projects\njrat7stubsoures – Copy\njrat7stubsoures\obj\Debug\dvvm.pdb') ] +file:bytes:mime:pe:pdbpath ~= tekide
::
  
  <query> +file:bytes:mime:pe:pdbpath ~= tekide

.. storm-pre:: [ (file:bytes=sha256:1a287331e2bfb4df9cfe2dab1b77c9b5522e923e52998a2b1934ed8a8e52f3a8 :mime='application/vnd.microsoft.portable-executable' :mime:pe:pdbpath='C:\Users\mr.tekide\Documents\Visual Studio 2013\Projects\njrat7stubsoures – Copy\njrat7stubsoures\obj\Debug\dvvm.pdb') ] +:mime:pe:pdbpath ~= tekide
::
  
  <query> +:mime:pe:pdbpath ~= tekide


*Filter the current working set to exclude organizations (ou:org nodes) whose name contains a string that starts with "v", followed by 0 or more characters, followed by "x":*

.. storm-pre:: [ (ou:org=4b0c2c5671874922ce001d69215d032f :name="the vertex project" :alias=vertex) (ou:org=ad8de4b5da0fccb2caadb0d425e35847 :name=vxunderground) ] -ou:org:name ~= '^v.*x'
::
  
  <query> -ou:org:name ~= '^v.*x'

.. storm-pre:: [ (ou:org=4b0c2c5671874922ce001d69215d032f :name="the vertex project" :alias=vertex) (ou:org=ad8de4b5da0fccb2caadb0d425e35847 :name=vxunderground) ] -:name ~= '^v.*x'
::
  
  <query> -:name ~= '^v.*x'


.. _filter-prefix:

Filter by Prefix (^=)
+++++++++++++++++++++

Synapse performs prefix indexing on strings and string-derived types, which optimizes filtering nodes whose *<valu>*
or *<pval>* starts with a given prefix (substring). The extended comparator ``^=`` is used to filter nodes by prefix.

.. NOTE::
  
  Extended string types that support dotted notation (such as the :ref:`type-loc` or :ref:`type-syn-tag` types)
  have custom behaviors with respect to lifting and filtering by prefix.
  
  :ref:`type-inet-fqdn` nodes are indexed in reverse string order so cannot be filtered using the prefix extended
  operator. However, reverse indexing allows wildcard ( ``*`` ) matching of the beginning of any FQDN string.
  
  See the relevant sections in the :ref:`storm-ref-type-specific` guide for details.


**Syntax:**

*<query>* **+** | **-** *<form>* **^=** *<prefix>*

*<query>* **+** | **-** [ *<form>* ] **:** | **.** | **:_** *<prop>* **^=** *<prefix>*

**Examples:**

*Filter the current working set to exclude email addresses (inet:email nodes) that start with "abuse":*

.. storm-pre:: [ inet:email=abuse@1and1.com inet:email=abuse.tor-exit@posteo.org ] -inet:email ^= abuse
::
  
  <query> -inet:email ^= abuse


*Filter the current working set to only include organizations (ou:org nodes) whose name starts with "ministry":*

.. storm-pre:: [ (ou:org=a7f31ce9809e103ddedf36c1e1e91249 :name='ministry for foreign affairs of finland') (ou:org=1560dc4129405e18fd32f30b6f01fa1f :name='ministry of finance of ukraine') ] +ou:org:name ^= ministry
::
  
  <query> +ou:org:name ^= ministry

.. storm-pre:: [ (ou:org=a7f31ce9809e103ddedf36c1e1e91249 :name='ministry for foreign affairs of finland') (ou:org=1560dc4129405e18fd32f30b6f01fa1f :name='ministry of finance of ukraine') ] +:name ^= ministry
::
  
  <query> +:name ^= ministry


.. _filter-interval:

Filter by Time or Interval (@=)
+++++++++++++++++++++++++++++++

The time extended comparator (``@=``) is used to filter nodes based on comparisons among various combinations
of times and intervals.

.. TIP::
  
  See :ref:`storm-ref-type-specific` for additional detail on the use and behavior of :ref:`type-time`
  and :ref:`type-ival` data types.


**Syntax:**

*<query>* **+** | **-** [ *<form>* ] **:** | **.** | **:_** *<prop>* **@=(** *<ival_min>* **,** *<ival_max>* **)**

*<query>* **+** | **-** [ *<form>* ] **:** | **.** | **:_** *<prop>* **@=** *<time>*

**Examples:**

*Filter the current working set to include only those DNS A records (inet:dns:a nodes) whose ``.seen`` values fall between July 1, 2022 and and August 1, 2022:*

.. storm-pre:: [ inet:dns:a=(easymathpath.com, 135.125.78.187) .seen=(2021/09/12 00:00:00, 2023/08/08 01:50:54.001) ] +inet:dns:a.seen @= ( 2022/07/01, 2022/08/01 )
::
  
  +inet:dns:a.seen @= ( 2022/07/01, 2022/08/01 )

.. storm-pre:: [ inet:dns:a=(easymathpath.com, 135.125.78.187) .seen=(2021/09/12 00:00:00, 2023/08/08 01:50:54.001) ] +.seen @= ( 2022/07/01, 2022/08/01 )
::
  
  +.seen @= ( 2022/07/01, 2022/08/01 )

*Filter the current working set to only include DNS requests (inet:dns:request nodes) that occurred on May 3, 2023 (between 05/03/2023 00:00:00 and 05/03/2023 23:59:59):*

.. storm-pre:: [ inet:dns:request="*" :time="2023/05/03 21:09:04.000" :query:name:fqdn=vertex.link ] +inet:dns:request:time @= ( '2023/05/03 00:00:00', '2023/05/04 00:00:00' )
::
  
  +inet:dns:request:time @= ( '2023/05/03 00:00:00', '2023/05/04 00:00:00' )

.. storm-pre:: [ inet:dns:request="*" :time="2023/05/03 21:09:04.000" :query:name:fqdn=vertex.link ] +:time @= ( '2023/05/03 00:00:00', '2023/05/04 00:00:00' )
::
  
  +:time @= ( '2023/05/03 00:00:00', '2023/05/04 00:00:00' )

.. TIP:
  
  Because the ``inet:dns:request:time`` property is a single date / time value, the following filters
  would also work:
  
  ``+inet:dns:request:time = 2023/05/03*``
  ``+:time = 2023/05/03*``


*Filter the current working set to only include DNS A records (inet:dns:a nodes) whose resolution time window includes the date December 1, 2023:*

.. storm-pre:: inet:dns:a +inet:dns:a.seen @= 2023/12/01
::
  
  <query> +inet:dns:a.seen @= 2017/12/01

.. storm-pre:: inet:dns:a +.seen@=2017/12/01
::
  
  <query> +.seen @= 2017/12/01


*Filter results to include only those domain WHOIS records (inet:whois:rec nodes) where the domain was registered (created) **exactly** on March 19, 2019 at 5:00 UTC:*

.. storm-pre:: inet:whois:rec +inet:whois:rec:created @= '2019/03/19 05:00:00'
::
  
  <query> +inet:whois:rec:created @= '2019/03/19 05:00:00'


.. storm-pre:: inet:whois:rec +:created @= '2019/03/19 05:00:00'
::
  
  <query> +:created @= '2019/03/19 05:00:00'

.. NOTE::
  
  When comparing a single time value to a time property, the ``@=`` comparator behaves just like the
  equal to ( ``=`` ) operator.


*Filtter the current working set tto only include WHOIS email nodes (inet:whois:email) that were observed between July 1, 2023 and the present:*

.. storm-pre:: [ inet:whois:email=(tfxdccssl.net, abuse@dynadot.com) .seen=(2013/12/13 00:00:00, 2023/07/30 04:05:15.001) ] +inet:whois:email.seen @= ( 2023/07/01, now )
::
  
  +inet:whois:email.seen @= ( 2023/07/01, now )

.. storm-pre:: [ inet:whois:email=(tfxdccssl.net, abuse@dynadot.com) .seen=(2013/12/13 00:00:00, 2023/07/30 04:05:15.001) ] +.seen @= ( 2023/07/01, now )
::
  
  +.seen @= ( 2023/07/01, now )

*Filter the current working set to only include the network flows (inet:flow nodes) that occurred within the past day:*

.. storm-pre:: [ inet:flow="*" :time=now ] +inet:flow:time @= ( now, '-1 day' )
::
  
  +inet:flow:time @= ( now, '-1 day' )

.. storm-pre:: [ inet:flow="*" :time=now ] +:time @= ( now, '-1 day' )
::
  
  +:time @= ( now, '-1 day' )


**Usage Notes:**

- When specifying an interval with the ``@=`` operator, the minimum value is included in the interval for
  comparison purposes but the maximum value is **not**. This is equivalent to "greater than or equal to
  *<min>* and less than *<max>*". This behavior differs from that of the ``*range=`` operator, which includes
  **both** the minimum and maximum.
- **Comparing intervals to intervals:** when using an interval with the ``@=`` operator to filter nodes based on
  an interval property, Synapse returns nodes whose interval value has **any** overlap with the specified
  interval. For example:

  - A lift interval of September 1, 2018 to October 1, 2018 ( 2018/09/01, 2018/10/01 ) will match nodes with any
    of the following intervals:
  
    - August 12, 2018 to September 6, 2018 ( 2018/08/12, 2018/09/06 ).
    - September 13, 2018 to September 17, 2018 ( 2018/09/13, 2018/09/17 ).
    - September 30, 2018 to November 5, 2018 ( 2018/09/30, 2018/11/05 ).

- **Comparing intervals to times:** When using an interval with the ``@=`` operator to lift nodes based on a time
  property, Synapse returns nodes whose time value falls within the specified interval.
- **Comparing times to times:** When using a time with the ``@=`` operattor to filter nodes based on a time property,
  Synapse returns nodes whose timestamp is an **exact match** of the specified time. In other words, in this case
  the interval comparator ( ``@=`` ) behaves like the equal to comparator ( ``=`` ).
- When specifying date / time and interval values, Synapse allows the use of both lower resolution values (e.g., ``YYYY/MM/DD``),
  and wildcard values (e.g., ``YYYY/MM*``). Wildcard time syntax may provide a simpler and more intuitive means to specify
  some intervals. For example ``inet:whois:rec:asof=2018*`` is equivalent to ``inet:whois:rec:asof@=('2018/01/01', '2019/01/01')``.
- Time-based keywords (such as ``now``) and relative time syntax (expressions such as ``+-1 hour`` or ``-7 days``) can be used
  for interval values.

  See the type-specific documentation for :ref:`type-time` and :ref:`type-ival` types for a detailed discussion of these behaviors.

.. _filter-range:

Filter by Range (\*range=)
++++++++++++++++++++++++++

The range extended comparator (``*range=``) supports filtering nodes whose *<form> = <valu>* or *<prop> = <pval>*
fall within a specified range of values. The comparator can be used with types such as integers and times.

.. NOTE::
  
  The ``*range=`` operator can be used to filter both ``inet:ipv4`` and ``inet:ipv6`` values (which are stored
  as decimal integers and strings, respectively). However, ranges of :ref:`type-inet-ipv4` and ``inet:ipv6``
  nodes can also be filtered directly by specifying a the lower and upper addresses in the range using
  ``<min>-<max>`` format. For example:
  
  ``+inet:ipv4 = 192.168.0.0-192.168.0.10``
  or
  ``+:ipv4 = 192.168.0.0-192.168.0.10``
  
  Because IPv6 nodes are stored as strings, the range must be enclosed in quotes:
  
  ``+inet:ipv6 = "::0-ff::ff"
  ``+:ipv6 = "::0-ff::ff"
    
  The ``*range=`` operator cannot be used to compare a time range with a property value that is an interval
  (``ival`` type). The interval ( ``@=`` ) operator should be used instead.

**Syntax:**

*<query>* **+** | **-** *<form>* ***range = (** *<range_min>* **,** *<range_max>* **)**

*<query>* **+** | **-** [ *<form>* ] **:** | **.** | **:_** *<prop>* ***range = (** *<range_min>* **,** *<range_max>* **)**

**Examples:**

*Filter by primary property in range:*

- Filter results to include all IP addresses between 192.168.0.0 and 192.168.0.10:

.. storm-pre:: inet:ipv4 +inet:ipv4*range=(192.168.0.0, 192.168.0.10)
::
    
    <query> +inet:ipv4*range=(192.168.0.0, 192.168.0.10)


*Filter by secondary property in range:*

- Filter results to include files whose size in bytes is within the specified range:

.. storm-pre:: file:bytes +file:bytes:size*range=(1000, 100000)
::
    
    <query> +file:bytes:size*range=(1000, 100000)


.. storm-pre:: file:bytes +:size*range=(1000, 100000)
::
    
    <query> +:size*range=(1000, 100000)


- Filter results to include WHOIS records that were captured between the specified dates:

.. storm-pre:: inet:whois:rec +inet:whois:rec:asof*range=(2013/11/29, 2016/06/14) 
::
    
    <query> +inet:whois:rec:asof*range=(2013/11/29, 2016/06/14)


.. storm-pre:: inet:whois:rec +:asof*range=(2013/11/29, 2016/06/14) 
::
    
    <query> +:asof*range=(2013/11/29, 2016/06/14)


- Filter results to include DNS requests made within 1 day of December 1, 2018:

.. storm-pre:: inet:dns:request +inet:dns:request:time*range=(2018/12/01, "+-1 day")
::
    
    <query> +inet:dns:request:time*range=(2018/12/01, "+-1 day")


.. storm-pre:: inet:dns:request +:time*range=(2018/12/01, "+-1 day")
::
    
    <query> +:time*range=(2018/12/01, "+-1 day")


**Usage Notes:**

- When specifying a range (``*range=``), both the minimum and maximum values are **included** in the
  range (the equivalent of "greater than or equal to *<min>* and less than or equal to *<max>*").
  This behavior is slightly different than that for time interval (``@=``), which includes the minimum
  but not the maximum.
- The ``*range=`` extended comparator can be used with time types, although the time / interval extended
  comparator ( ``@=`` ) is preferred.
- When specifying a range of time values, Synapse allows you to use either lower resolution values
  (e.g., ``YYYY/MM/DD``) or wildcard values (e.g., ``YYYY/MM*``) for the minimum and/or maximum range
  values. In addition, plain wildcard time syntax may provide a simpler and more intuitive means to specify
  some time ranges. For example ``+inet:whois:rec:asof=2018*`` (or ``+:asof=2018*``) is equivalent to
  ``+inet:whois:rec:asof*range=('2018/01/01', '2018/12/31 23:59:59.999')`` (or
  ``+:asof*range=('2018/01/01', '2018/12/31 23:59:59.999')``).  See the type-specific documentation for
  :ref:`type-time` types for a detailed discussion of these behaviors.

.. _filter-set:

Filter by Set Membership (\*in=)
++++++++++++++++++++++++++++++++

The set membership extended comparator (``*in=``) supports filtering nodes whose *<form> = <valu>* or
*<prop> = <pval>* matches any of a set of specified values. The comparator can be used with any type.

**Syntax:**

*<query>* **+** | **-** *<form>* | *<prop>* ***in = (** *<set_1>* **,** *<set_2>* **,** ... **)**

**Examples:**

*Filter by primary property in set:*

- Filter results to include IP addresses matching any of the specified values:

.. storm-pre:: inet:ipv4 +inet:ipv4*in=(127.0.0.1, 192.168.0.100, 255.255.255.254)
::
    
    <query> +inet:ipv4*in=(127.0.0.1, 192.168.0.100, 255.255.255.254)


*Filter by secondary property in set:*

- Filter results to include files whose size in bytes matches any of the specified values:

.. storm-pre:: file:bytes +file:bytes:size*in=(4096, 16384, 65536)
::
    
    <query> +file:bytes:size*in=(4096, 16384, 65536)


.. storm-pre:: file:bytes +:size*in=(4096, 16384, 65536)
::
    
    <query> +:size*in=(4096, 16384, 65536)


- Filter results to exclude tags that end in ``foo``, ``bar``, or ``baz``:

.. storm-pre:: [syn:tag=foo.bar.baz] -syn:tag:base*in=(foo, bar, baz)
::
    
    <query> -syn:tag:base*in=(foo, bar, baz)


.. storm-pre:: syn:tag -:base*in=(foo, bar, baz)
::
    
    <query> -:base*in=(foo, bar, baz)


.. _filter-proximity:

Filter by Proximity (\*near=)
+++++++++++++++++++++++++++++

The proximity extended comparator (``*near=``) supports filtering nodes by "nearness" to another node
based on a specified property type. Currently, ``*near=`` supports proximity based on geospatial
location (that is, nodes within a given radius of a specified latitude / longitude).

**Syntax:**

*<query>* **+** | **-** *<form>* | *<prop>* ***near = ((** *<lat>* **,** *<long>* **),** *<radius>* **)**

**Examples:**

*Filter by proximity:*

- Filter results to include only Acme Corporation offices within 1 km of a specific coffee shop:

.. storm-pre:: [geo:place="*" :latlong="37.7825315,-122.4236523"] +geo:place:latlong*near=((47.6050632,-122.3339756),1km)
::
  
  <query> +geo:place:latlong*near=((47.6050632,-122.3339756),1 km)

.. storm-pre:: geo:place +:latlong*near=((47.6050632,-122.3339756),1 km)
::
  
  <query> +:latlong*near=((47.6050632,-122.3339756),1 km)


- Filter results to include only Acme Corporation offices within 1 mile of a specific coffee shop:

.. storm-pre:: geo:place +geo:place:latlong*near=((47.6050632,-122.3339756), 1 mile)
::
  
  <query> +geo:place:latlong*near=((47.6050632,-122.3339756), 1 mile)

.. storm-pre:: geo:place +:latlong*near=((47.6050632,-122.3339756), 1 mile)
::
  
  <query> +:latlong*near=((47.6050632,-122.3339756), 1 mile)


**Usage Notes:**

- In the example above, the latitude and longitude of the desired location (i.e., the coffee shop) are
  explicitly specified as parameters to ``*near=``.
- Radius can be specified in the following units. The values in parentheses are the acceptable terms
  for specifying a given unit:

  - Kilometers (km / kilometer / kilometers)
  - Meters (m / meter / meters)
  - Centimeters (cm / centimeter / centimeters)
  - Millimeters (mm / millimeter / millimeters)
  - Miles (mile / miles)
  - Yards (yard / yards)
  - Feet (foot / feet)

- When specifying a radius, values of less than 1 must be specified with a leading zero (e.g., ``0.5 km``
  is valid; ``.5 km`` is not).

- The ``*near=`` comparator works by identifying nodes within a square bounding box centered at
  *<lat>, <long>*, then filters the nodes to be returned by ensuring that they are within the great-circle
  distance given by the *<radius>* argument.

.. _filter-by-arrays:

Filter by (Arrays) (\*[ ])
++++++++++++++++++++++++++

Storm uses a special "by" syntax to filter (or lift) by comparison with one or more elements of an
:ref:`type-array` type. The syntax consists of an asterisk ( ``*`` ) preceding a set of square brackets
( ``[ ]`` ), where the square brackets contain a comparison operator and a value that can match one or
more elements in the array. This allows users to match any value in the array list without needing to
know the exact order or values of the array itself.

**Syntax:**

*<query>* **+** | **-** *<prop>* ***[** *<operator>* *<pval>* **]**

**Examples:**

- Filter results to include only x509 certificates that reference a specific email address:

.. storm-pre:: [inet:fqdn=woot.com inet:fqdn=vertex.link inet:fqdn=google.com]
::
    
    <query> +:identities:emails*[=root@localhost.localdomain]


- Filter results to exclude organizations whose names start with "ministry":

.. storm-pre:: ou:org -:names*[^=ministry]
::
    
    <query> -:names*[^=ministry]


**Usage Notes:**

- Filter operations using secondary properties of type :ref:`type-array` must specify the property
  using its relative property name. Filtering using the full property syntax will generate an error.

  - ``ou:org | limit 10 | +:names*[=vertex]`` is valid syntax.
  - ``ou:org | limit 10 | +ou:org:names*[=vertex]`` is invalid syntax.

- The comparison operator used must be valid for filter operations for the type used in the array.
- The standard equals ( ``=`` ) operator can be used to filter nodes based on array properties, but
  the value specified must **exactly match** the **full** property value in question:

  - For example: ``ou:org +:names=("the vertex project","the vertex project llc",vertex)`` will
    filter to any ``ou:org`` nodes whose ``:names`` property consists of **exactly** those names in
    **exactly** that order.

- See the :ref:`type-array` section of the :ref:`storm-ref-type-specific` document for additional
  details on working with arrays.

.. _filter-tag:

Filter by Tag (#)
+++++++++++++++++

The tag extended comparator (``#``) supports filtering nodes based on the tags applied to a node.
You can filter based on a given tag or on the timestamps associated with a given tag (using the
interval comparator, ``@=``).

.. NOTE::
  
  You can also use "filter by tag" to filter nodes based on any tags with tag properties, or tags
  with tag properties and specific tag property values, if tag properties are present in your data
  model.
  
  :ref:`tag-properties` are still supported by Synapse, but their use has largely been deprecated
  in favor of extended model properties where needed.


**Syntax:**

*<query>* **+** | **-** **#** *<tag>*

*<query>* **+** | **-** **#** *<tag>* **@=** *<time>* | **(** *<min>* **,** *<max>* **)**

**Examples:**

*Filter by tag:*

- Filter results to include only nodes that ESET says are part of the Seduploader malware family:


.. storm-pre:: inet:fqdn=woot.com inet:fqdn=vertex.link inet:fqdn=google.com +#rep.eset.seduploader
::
    
    <query> +#rep.eset.seduploader


- Filter results to exclude nodes tagged as being associated with the TOR network:


.. storm-pre:: inet:ipv4 -#cno.infra.anon.tor
::
    
    <query> -#cno.infra.anon.tor


- Filter results to exclude nodes tagged as sinkholes:


.. storm-pre:: inet:ipv4 -#cno.infra.dns.sinkhole
::
    
    <query> -#cno.infra.dns.sinkhole


*Filter by tag and time:*

- Filter results to include only nodes that were associated with TOR infrastructure as of December 12, 2019:


.. storm-pre:: inet:fqdn +#cno.infra.anon.tor@=2019/12/12
::
    
    <query> +#cno.infra.anon.tor@=2019/12/12


*Filter by tag and time interval:*

- Filter results to include only those nodes associated with sinkhole infrastructure between January 1,
  2017 and January 1, 2018:


.. storm-pre:: [inet:fqdn=woot.com inet:fqdn=vertex.link inet:fqdn=google.com]
::
    
    <query> +#cno.infra.dns.sinkhole@=(2017/01/01, 2018/01/01)


- Filter results to exclude nodes associated with threat cluster 17 after January 1, 2019:


.. storm-pre:: inet:fqdn -#cno.threat.t17.own@=(2019/01/01, now)
::
    
    <query> -#cno.threat.t17.own@=(2019/01/01, now)



- Filter results to include only those nodes (e.g., IP addresses) that were associated with TOR network
  infrastructure between June 1, 2016 and September 30, 2016 (note the interval here applies to the
  timestamps for the **tag** that indicates a node was associated with TOR):

.. storm-pre:: inet:ipv4=1.2.3.4 +#cno.infra.anon.tor@=(2016/06/01, 2016/09/30)
::
    
    <query> +#cno.infra.anon.tor@=(2016/06/01, 2016/09/30)



**Usage Notes**

- When filtering by tag, you can only specify a single tag (though you can specify a tag "higher up"
  in a tag tree to encompass any / all tags lower in the tree - e.g., ``+#foo.bar`` will include any
  nodes with the tag ``#foo.bar.hurr``, ``#foo.bar.derp``, etc.). To filter on multiple different tags,
  use `Compound Filters`_.
- Tag timestamps are interval (``ival``) types. See the :ref:`type-time` and :ref:`type-ival` sections
  of the :ref:`storm-ref-type-specific` document for additional details on working with times and intervals.

.. _filter-compound:

Compound Filters
----------------

Storm allows you to use the logical operators **and**, **or**, and **not** (including **and not**) to
construct compound filters. You can use parentheses to group portions of the filter statement to indicate
order of precedence and clarify logical operations when evaluating the filter.

**Syntax:**

*<query>* **+** | **-** **(** *<filter>* **and** | **or** | **not** | **and not** ... **)**

**Examples:**

- Filter results to exclude files that are less than or equal to 16384 bytes in size and were compiled
  prior to January 1, 2014:

.. storm-pre:: [file:bytes=sha256:2d168c4020ba0136cd8808934c29bf72cbd85db52f5686ccf84218505ba5552e :mime:pe:compiled="1992/06/19 22:22:17.000"] -(file:bytes:size <= 16384 and file:bytes:mime:pe:compiled < 2014/01/01)
::
    
    <query> -(file:bytes:size <= 16384 and file:bytes:mime:pe:compiled < 2014/01/01)


.. storm-pre:: file:bytes -(:size <= 16384 and :mime:pe:compiled < 2014/01/01)
::
    
    <query> -(:size <= 16384 and :mime:pe:compiled < 2014/01/01)


- Filter results to include only files or domains that ESET claims are associated with Sednit:


.. storm-pre:: .created +((file:bytes or inet:fqdn) and #rep.eset.sednit)
::
    
    <query> +((file:bytes or inet:fqdn) and #rep.eset.sednit)


- Filter results to include only files and domains that ESET claims are associated with Sednit that are **not**
  sinkholed:

.. storm-pre:: .created +((file:bytes or inet:fqdn) and (#rep.eset.sednit and not #cno.infra.dns.sinkhole))
::
    
    <query> +((file:bytes or inet:fqdn) and (#rep.eset.sednit and not #cno.infra.dns.sinkhole))


**Usage Notes:**

- Logical operators must be specified in lower case.
- Synapse evalutes compound filters **in order from left to right**. Depending on the specific filter,
  left-to-right order may differ from the standard Boolean order of operations (**not** then **and**
  then **or**).
- Parentheses should be used to logically group portions of the filter statement if necessary to
  clarify order of operations.


.. _filter-subquery:

Subquery Filters
----------------

You can use Storm's subquery syntax (:ref:`storm-ref-subquery`) to create filters. A subquery
(enclosed in curly braces ( ``{ }`` ) ) can be placed within a larger Storm query.

When nodes are passed to a subquery filter, they are evaluated against the filter's criteria:

- Nodes are **excluded** ("consumed", discarded) if they evaluate **false.**
- Nodes are **included** (not "consumed", retained) if they evaluate **true.**

Most filter operations in Storm will modify (reduce) your current set of nodes based on some
criteria of the **nodes themselves** (e.g., a node's form, property, or tag).

Subquery filters allow you to filter your **current** set of nodes based on some criteria of
**nearby** nodes. You use the subquery filter to effectively "look ahead" at nodes one or more
pivots away from your current nodes, and filter your current nodes based on the properties
of those "nearby" nodes.

The subquery pivot operation (used to "look ahead" at other nodes) is effectively performed in
the background (without navigating away from your current working set), which provides a more
powerful and efficent way to filter your data. (The alternative would be to **actually** navigate
to the nearby nodes, filter those nodes, and then navigate **back** to the data you are interested in.)

You can optionally use a mathematical comparison operation with a subquery filter, in order to
filter your current set of nodes based on the **number of results** returned by executing the
subfilter's Storm query (see example below).

Refer to the :ref:`storm-ref-subquery` guide for additional information on subqueries and subquery filters.

**Syntax:**

*<query>* **+** | **-** **{** *<query>* **}**

*<query>* **+** | **-** **{** *<query>* **}** [ *<mathematical operator>* *<value>* ]

**Examples:**

- From an initial set of domains, filter results to only those domains that resolve to an IP address
  that Trend Micro associates with the Pawn Storm threat group (i.e., an IP address tagged
  ``#rep.trend.pawnstorm``):

.. storm-pre:: inet:fqdn +{ -> inet:dns:a:fqdn :ipv4 -> inet:ipv4 +#rep.trend.pawnstorm }
::

    <inet:fqdn> +{ -> inet:dns:a:fqdn :ipv4 -> inet:ipv4 +#rep.trend.pawnstorm }


- From an initial set of IPv4 addresses, filter results to only those IPv4s registered to an Autonomous
  System (AS) whose name starts with "makonix":

.. storm-pre:: inet:ipv4 +{ :asn -> inet:asn +:name^="makonix" }
::

    <inet:ipv4> +{ :asn -> inet:asn +:name^="makonix" }


- From an initial set of ``file:bytes`` nodes, filter results to only those that are detected as
  malicious by ten (10) or more antivirus / malscanner vendors (i.e., files that are associated with
  10 or more ``it:av:filehit`` nodes):

.. storm-pre:: file:bytes +{ -> it:av:filehit }>=10
::

    <file:bytes> +{ -> it:av:filehit }>=10

- From an initial set of x509 certificates (``crypto:x509:cert``), filter results to only those
  certificates linked to more than one FQDN (``inet:fqdn``) identity:

.. storm-pre:: [ ( crypto:x509:cert=* :identities:fqdns=(woot.com,) ) ( crypto:x509:cert=* :identities:fqdns=(hurr.net, derp.org) ) ] +{ :identities:fqdns -> inet:fqdn }>1
::
  
  <crypto:x509:cert> +{ :identities:fqdns -> inet:fqdn }>1


.. _filter-expression:

Expression Filters
------------------

You can filter your current set of data (nodes) based on the evaluation of a particular expression.
Expression filters are useful when you need to compute a value that you want to use for the filter,
or when you want to filter based on a value that may change (e.g., when using Storm queries that
assign variables - see :ref:`storm-adv-vars`).

**Syntax:**

*<query>* **+** | **-** **$(** *<expression>* **)**


**Examples:**

- From an initial set of network flows (``inet:flow`` nodes), filter results to only those flows where
  the total number of bytes transferred in the flow between the source (``inet:flow:src:txbytes``) and
  destination (``inet:flow:dst:txbytes``) is greater than 100MB (~100,000,000 bytes):

.. storm-pre:: [ ( inet:flow=* :src:txbytes=60000000 :dst:txbytes=60000000 ) ( inet:flow=* :src:txbytes=1024 :dst:txbytes=4096 ) ] +$( :src:txbytes + :dst:txbytes >=100000000 )
::
  
  <inet:flow> +$( :src:txbytes + :dst:txbytes >=100000000 )


- From an initial set of x509 certificates (``crypto:x509:cert``), filter results to only those
  certificates linked to more than one FQDN (``inet:fqdn``) identity:

.. storm-pre:: [ ( crypto:x509:cert=* :identities:fqdns=(woot.com,) ) ( crypto:x509:cert=* :identities:fqdns=(hurr.net, derp.org) ) ] $fqdns=:identities:fqdns +$( $fqdns.size() > 1 )
::
  
  <crypto:x509:cert> $fqdns=:identities:fqdns +$( $fqdns.size() > 1 )

This example assigns the list of domains in the ``crypto:x509:cert:identities:fqdns`` property to the
user-defined variable ``$fqdns``, computes the number of domains in the list using :ref:`stormprims-list-size`,
and checks to see if the result is greater than 1.

(See the :ref:`stormtypes_index` for additional detail on Storm types and Storm libraries.)

.. NOTE::
    
    This certificates example is identical to the final example under :ref:`filter-subquery` above, and
    shows an alternate way to return the same data.
    
    The expression filter above is more efficient than the subquery filter because the expression
    filter simply evaluates the expression, where the subquery filter needs to pivot to the adjacent
    nodes in order to evaluate the results. This difference in performance is negligible for small
    data sets but more pronounced when working with large numbers of nodes.


- From the set of nodes associated with any threat group or threat cluster (e.g., tagged
  ``#cno.threat.<threat_name>``), filter results to those nodes that are attributed to more than one
  threat (e.g., that have more than one ``#cno.threat.<threat_name>`` tag. This may identify nodes that
  are incorrectly attributed to more than one group; or instances where two threat clusters overlap,
  which may indicate that the clusters actually represent a single set of activity):

.. storm-pre:: [ ( inet:ipv4=4.4.4.4 +#cno.threat.foo ) ( inet:ipv4=7.7.7.7 +#cno.threat.hurr +#cno.threat.derp ) ] +$( $node.globtags(cno.threat.*).size() > 1 )
::
  
  #cno.threat +$( $node.globtags(cno.threat.*).size() > 1 )

This example uses the :ref:`meth-node-globtags` method to select the set of tags on each node that
match the specified expression (``cno.threat.*``) and :ref:`stormprims-list-size` to count the number
of matches.


.. _embed_prop_syntax:

Embedded Property Syntax
------------------------

Storm includes a shortened syntax consisting of two colons (``::``) that can be used to reference a
secondary property of an **adjacent** node. Because the syntax can be used to "pull in" a property or
property value from a nearby node, it is known as "embedded property syntax".

Embedded property syntax expresses something that is similar (in concept, though not in practice) to a
secondary-to-secondary property pivot (see :ref:`storm-ref-pivot`). The syntax expresses navigation:

- From a **secondary property** of a form (such as ``inet:ipv4:asn``), to
- The **form** for that secondary property (i.e., ``inet:asn``), to
- A **secondary property** (or property value) of that **target form** (such as ``inet:asn:name``).

This process can be repeated to reference properties of forms more than one pivot away.

Despite its similarity to a pivot operation, embedded property syntax is commonly used for:

- **Filter operations** (specifically, as a more concise alternative to certain :ref:`filter-subquery`)
- **Variable assignment** (see :ref:`storm-adv-vars`)
- Defining an :ref:`gloss-embed-col` in the Synapse UI (Optic)


**Syntax:**

*<query>* [ **+ | -** ] **:** *<prop>* **::** *<prop>*

*<query>* [ **+ | -** ] **:** *<prop>* **::** *<prop>* **=** *<pval>*

.. NOTE::
  
  In Storm, the leading colon (i.e., the colon before the name of the initial secondary property) is
  **required**. When using this syntax to create an embed column in Optic, the initial colon should be
  **omitted** (i.e., ``asn::name`` vs ``:asn::name``). Optic will prepend the initial colon for you.


**Examples:**


*Filter Example - Single Pivot*

- From an initial set of IPv4 addresses, filter results to only those IPv4s registered to an Autonomous
  System (AS) whose name starts with "makonix":

.. storm-pre:: [ (inet:ipv4=185.86.150.67 :asn=52173) (inet:asn=52173 :name="makonix, lv") ] +:asn::name^="makonix"
::

    <inet:ipv4> +:asn::name^="makonix"

Note that this example of embedded property syntax is equivalent to the following subquery filter
(referenced above):

::

    <inet:ipv4> +{ :asn -> inet:asn +:name^="makonix" }


*Filter Example - Multiple Pivots*

- From an initial set of ``it:exec:file:read`` operations, filter results to only those operations where
  the base file name of the PDB path of the file performing the read operation is ``moonclient2.pdb``:

.. storm-pre:: [ ( it:exec:file:read=1fe9e8690b76f84680468b4018cc3655 :sandbox:file=sha256:708840e33fe6632ba75fcf86564e0a2ece4f7b265390afe15aa5ae383a917e65 ) ( file:bytes=sha256:708840e33fe6632ba75fcf86564e0a2ece4f7b265390afe15aa5ae383a917e65 :mime:pe:pdbpath='e:/code/moon1.5/release/moonclient2.pdb' ) ] +:sandbox:file::mime:pe:pdbpath::base=moonclient2.pdb
::

  <it:exec:file:read> +:sandbox:file::mime:pe:pdbpath::base=moonclient2.pdb


*Variable Assignment Example*

- Set the variable ``$name`` to the name of the Autonomous System (AS) associated with a given IPv4
  address:

.. storm-pre:: inet:ipv4 $name=:asn::name
::

    <inet:ipv4> $name=:asn::name
    
    
    
.. _Vertex-Threat-Intel: https://synapse.docs.vertex.link/projects/rapid-powerups/en/latest/storm-packages/vertex-threat-intel/index.html
