
Data Model - Node Concepts
==========================

Recall from `Data Model – Basics`__ that the key data model components within Synapse are **nodes** and **tags.** Broadly speaking:

- Nodes commonly represent "facts" or "observables": things that are objectively true or verifiable.

- Tags commonly represent information that may be more changeable over time. Most commonly, tags represent "analytical assessments": conclusions drawn from observables that may change if data or the assessment of the data changes. In some cases, tags represent “facts” that may change over time, such as the geolocation of an IP address (represented by a location tag ``#loc``) or the association of an IP address with a specialized service, such as a TOR exit node or a VPN provider.

Nodes, however, can represent a number of different types of observables:

- **Objects.** Nodes can represent atomic "things", whether real or abstract. In the knowledge domain of cyber threat data, "object" node types include domains, IP addresses (IPv4 or IPv6), hosts (computers / devices), usernames, passwords, accounts, files, social media posts, and so on. Other object types might include people, organizations, countries, bank or financial accounts, units of currency, chemical elements or formulas, telephone numbers, airline flights, and so on. Any "thing" can be represented as a node.

  In some cases, it may be useful to represent both generic and specific instances of a thing. For example, let's say you wish to represent vehicles in your hypergraph. It can be useful to create nodes for the Honda Accord and the Ford Focus to represent different makes and models of vehicles. However, depending on the type of analysis being performed, it may also be useful to represent individual vehicles – Bob Smith's Honda, or the Ford Focus with Vehicle Identification Number (VIN) 1HGBH41JXMN109186. (Synapse supports these concepts with the ``mat:spec`` (material specification) and ``mat:item`` (material item) forms.) Similarly, in the field of biology it might be useful to create a node representing the species *orcinus orca* as well as nodes representing individual killer whales.
  
- **Relationships.** Nodes can represent specific relationships among objects. Recall that in a directed graph a relationship is represented as a directed edge (*e*) joining exactly two nodes (*n1, n2*); but in a hypergraph the entire relationship is represented by a single node, and the relationship can encompass any number of objects – not just two.
  
  In the knowledge domain of cyber threat data, relationships may include a domain resolving to an IP address, a malware binary writing a file to disk, or a threat actor moving laterally between two hosts. Other types of relationships could include a company being a subsidiary of another business, or the ownership of an object (such as a car) by an individual or organization. As an example of a "multi-dimensional" relationship, biological parentage could be represented by a three-way relationship among two genetic parents and an offspring.
  
- **Events.** The term "event" implies that an object existed or a relationship occurred at a particular point in **time.** Nodes can represent time-based events; these can be thought of as "instance knowledge" as opposed to “fused” knowledge (which can be thought of knowledge that summarizes or “fuses” the data from any number of instance knowledge nodes). Examples include the results of a point-in-time domain lookup / domain resolution (DNS A record), the temperature reading in a city on a given date, or a domain registration ("whois") record captured on a specific date.

  Another way to look at events in contrast to relationships is that each type of node provides a difference in data granularity. Whether to create a relationship-type node or an event-type node may depend on how much detail is required for a given analytical purpose. This consideration often applies to relationships that change over time, particularly those that may change frequently.
  
  An example from cyber threat data is a DNS A record. The IP that a domain resolves to may change infrequently (e.g., for a website hosted on a stable server) or may change quite often (where the IP is dynamically assigned, or where load balancing is used, for example). One option to represent and track DNS A records would be to create an individual timestamped node (an event) **every time** you check the domain's current resolution; this would represent a very high degree of granularity as the node would record the exact time a domain resolved to a given IP, potentially down to the millisecond. However, the number of such nodes could readily reach into the hundreds of millions, if not billions, if you create a node for every resolution of every domain you want to track.
  
  An alternative would be to decide that it is sufficient to know that a domain resolved to an IP address **during a   given period of time** – an "earliest observed" (``seen:min``) and "last observed" (``seen:max``) range. A single node can be created to show that domain ``woot.com`` resolved to IP address ``1.2.3.4``, and that the earliest observed resolution was 8/6/2011 at 13:56, and the most recently observed resolution was 5/29/2016 at 7:32. These timestamps can be "moved out" (earlier or later) if additional data causes us to revise our observation boundaries. While this approach loses some granularity – the domain is not guaranteed to have resolved to that IP during the **entire** period, and we don't know exactly when it resolved there **during** that period. But it may be sufficient for our needs, and may be preferable to creating thousands of nodes for individual resolutions. In essence, this type of time-bounded relationship node "fuses" what could have been thousands of individual timestamped DNS A record nodes into a single time-bounded node. Of course, a hybrid approach is also possible, where most DNS A record data is recorded in fused nodes (e.g., ``inet:dns:a`` nodes) but it is also possible to record a high-resolution, point-in-time event when needed (e.g., ``inet:dns:look`` nodes).
  
  Additional examples include malware behavior and environmental observations. In some circumstances, it may be enough to know that when a malware binary is executed, it drops (writes) a specific file (a set of bytes with a specific hash) to disk; this would represent relationship-type “fused knowledge” (e.g., “file1 writes file2”). In other circumstances, it may be important to know not only what file was dropped, but also the specific filename and directory path used, or the specific configuration of the computer or sandbox where the malware executed; this would represent specific event-based “instance knowledge”.
  
  Similarly, with environmental observations (temperature, humidity, barometric pressure, etc.) it may be sufficient to know that in a given location (city, latitude / longitude), the recorded temperature has varied between two upper and lower bounds; in other circumstances, it may be important to know the specific temperature observation at a specific point in time.
  
Deconflicted vs. Non-Deconflicted Nodes
---------------------------------------

For performance purposes, Synapse supports the use of both **deconflicted** and **non-deconflicted** nodes. **Deconflicted nodes** must be unique within the hypergraph; if you ask Synapse to create a node whose type must be deconflicted, Synapse will first check to see whether the node already exists. This initial read operation slightly delays node creation (write operation) where the node does not yet exist, but avoids the overhead of a full write if the node is already present. Most "object" and "relationship" nodes are deconflicted nodes.

(One notable exception is nodes whose primary property is a randomly-generated GUID, such as people (``ps:person``) or organizations (``ou:org``). If the GUID is generated by Synapse itself using the “star” ( ``*`` ) syntax, Synapse guarantees the GUIDs are unique within a given Cortex, so the node does not need to be deconflicted before it is created. Essentially a request such as ``addnode(ps:person, *)`` translates to “create an arbitrary ``ps:person`` node with a randomly generated GUID and no predefined secondary properties”.)

**Non-deconflicted nodes** are known or assumed to be unique *a priori*; as such there is no need to check for the node's prior existence. Synapse skips any deconfliction check (read operation) and simply creates the node. Many “event” nodes are non-deconflicted nodes because they are assumed to be sufficiently high-resolution to represent data from a single, non-re-encounterable point in time. Some high-volume data types (e.g., streaming records, such as event logs) may be purposely designed as non-deconflicted to make the ingest of such data more performant. In addition, data that is deconflicted in advance (e.g., external to Synapse) and therefore known to be unique can be ingested as non-deconflicted data.

.. _Basics: ../userguides/ug003_dm_basics.html
__ Basics_
