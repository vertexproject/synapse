import shlex
import argparse

class Parser(argparse.ArgumentParser):

    def __init__(self, prog=None, descr=None):

        self.printf = None
        self.exited = False

        argparse.ArgumentParser.__init__(self,
            prog=prog,
            description=descr,
            formatter_class=argparse.RawDescriptionHelpFormatter)

    def exit(self, *args, **kwargs):
        # yea....  newp.
        self.exited = True

    def _print_message(self, text, fd=None):

        if self.printf is None:
            return

        for line in text.split('\n'):
            self.printf(line)

class Cmd:
    '''
    A one line description of the command.

    Command usage details and long form description.

    Example:

        cmd --help
    '''
    name = 'cmd'

    def __init__(self, text):
        self.opts = None
        self.text = text
        self.argv = self.getCmdArgv()
        self.pars = self.getArgParser()

    @classmethod
    def getCmdBrief(clas):
        return clas.__doc__.strip().split('\n')[0]

    def getCmdArgv(self):
        return shlex.split(self.text)

    def getArgParser(self):
        return Parser(prog=self.name, descr=self.__class__.__doc__)

    def reqValidOpts(self, snap):
        self.pars.printf = snap.printf
        self.opts = self.pars.parse_args(self.argv)
        return self.pars.exited

    def runStormCmd(self, snap, genr):
        yield from genr

class HelpCmd(Cmd):
    '''
    List available commands and a brief description for each.
    '''
    name = 'help'

    def getArgParser(self):
        pars = Cmd.getArgParser(self)
        pars.add_argument('command', nargs='?', help='Show the help output for a given command.')
        return pars

    def runStormCmd(self, snap, genr):

        yield from genr

        if not self.opts.command:
            for name, ctor in sorted(snap.core.getStormCmds()):
                snap.printf('%.20s: %s' % (name, ctor.getCmdBrief()))

        snap.printf('')
        snap.printf('For detailed help on any command, use <cmd> --help')

class LimitCmd(Cmd):
    '''
    Limit the number of nodes generated by the query in the given position.

    Example:

        inet:ipv4 | limit 10
    '''

    name = 'limit'

    def getArgParser(self):
        pars = Cmd.getArgParser(self)
        pars.add_argument('count', type=int, help='The maximum number of nodes to yield.')
        return pars

    def runStormCmd(self, snap, genr):

        for count, item in enumerate(genr):

            if count >= self.opts.count:
                snap.printf(f'limit reached: {self.opts.count}')
                break

            yield item

class DelNodeCmd(Cmd):
    '''
    Delete nodes produced by the previous query logic.

    (no nodes are returned)

    Example

        inet:fqdn=vertex.link | delnode
    '''
    name = 'delnode'

    def getArgParser(self):
        pars = Cmd.getArgParser(self)
        forcehelp = 'Force delete even if it causes broken references (requires admin).'
        pars.add_argument('--force', default=False, action='store_true', help=forcehelp)
        return pars

    def runStormCmd(self, snap, genr):

        # a bit odd, but we need to be detected as a generator
        yield from ()

        if self.opts.force:
            if snap.user is not None and not snap.user.admin:
                mesg = '--force requires admin privs.'
                return self._onAuthDeny(mesg)

        for node in genr:
            node.delete(force=self.opts.force)

class SudoCmd(Cmd):
    '''
    Use admin priviliges to bypass standard query permissions.

    Example:

        sudo | [ inet:fqdn=vertex.link ]
    '''
    name = 'sudo'

    def runStormCmd(self, snap, genr):
        snap.elevated = True
        yield from genr
