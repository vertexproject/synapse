import shlex
import logging
import argparse

import synapse.exc as s_exc
import synapse.common as s_common

logger = logging.getLogger(__name__)

class Parser(argparse.ArgumentParser):

    def __init__(self, prog=None, descr=None):

        self.printf = None
        self.exited = False

        argparse.ArgumentParser.__init__(self,
            prog=prog,
            description=descr,
            formatter_class=argparse.RawDescriptionHelpFormatter)

    def exit(self, *args, **kwargs):
        # yea....  newp.
        self.exited = True

    def _print_message(self, text, fd=None):

        if self.printf is None:
            return

        for line in text.split('\n'):
            self.printf(line)

class Cmd:
    '''
    A one line description of the command.

    Command usage details and long form description.

    Example:

        cmd --help
    '''
    name = 'cmd'

    def __init__(self, text):
        self.opts = None
        self.text = text
        self.argv = self.getCmdArgv()
        self.pars = self.getArgParser()

    @classmethod
    def getCmdBrief(clas):
        return clas.__doc__.strip().split('\n')[0]

    def getCmdArgv(self):
        return shlex.split(self.text)

    def getArgParser(self):
        return Parser(prog=self.name, descr=self.__class__.__doc__)

    def reqValidOpts(self, snap):
        self.pars.printf = snap.printf
        self.opts = self.pars.parse_args(self.argv)
        return self.pars.exited

    def runStormCmd(self, snap, genr):
        yield from genr

class HelpCmd(Cmd):
    '''
    List available commands and a brief description for each.
    '''
    name = 'help'

    def getArgParser(self):
        pars = Cmd.getArgParser(self)
        pars.add_argument('command', nargs='?', help='Show the help output for a given command.')
        return pars

    def runStormCmd(self, snap, genr):

        yield from genr

        if not self.opts.command:
            for name, ctor in sorted(snap.core.getStormCmds()):
                snap.printf('%.20s: %s' % (name, ctor.getCmdBrief()))

        snap.printf('')
        snap.printf('For detailed help on any command, use <cmd> --help')

class LimitCmd(Cmd):
    '''
    Limit the number of nodes generated by the query in the given position.

    Example:

        inet:ipv4 | limit 10
    '''

    name = 'limit'

    def getArgParser(self):
        pars = Cmd.getArgParser(self)
        pars.add_argument('count', type=int, help='The maximum number of nodes to yield.')
        return pars

    def runStormCmd(self, snap, genr):

        for count, item in enumerate(genr):

            if count >= self.opts.count:
                snap.printf(f'limit reached: {self.opts.count}')
                break

            yield item

class DelNodeCmd(Cmd):
    '''
    Delete nodes produced by the previous query logic.

    (no nodes are returned)

    Example

        inet:fqdn=vertex.link | delnode
    '''
    name = 'delnode'

    def getArgParser(self):
        pars = Cmd.getArgParser(self)
        forcehelp = 'Force delete even if it causes broken references (requires admin).'
        pars.add_argument('--force', default=False, action='store_true', help=forcehelp)
        return pars

    def runStormCmd(self, snap, genr):

        # a bit odd, but we need to be detected as a generator
        yield from ()

        if self.opts.force:
            if snap.user is not None and not snap.user.admin:
                mesg = '--force requires admin privs.'
                return self._onAuthDeny(mesg)

        for node in genr:
            node.delete(force=self.opts.force)

class SudoCmd(Cmd):
    '''
    Use admin priviliges to bypass standard query permissions.

    Example:

        sudo | [ inet:fqdn=vertex.link ]
    '''
    name = 'sudo'

    def runStormCmd(self, snap, genr):
        snap.elevated = True
        yield from genr

class TaskCmd(Cmd):
    '''
    Queue a node for consumption by a persistent task queue.

    Tasking nodes to a single service:

        ask < some lift > | task fooService

    Additional keyword args may be provided, as pairs, to the task:

        ask < some lift > | task -k arg1 valu1 -k arg2 valu2 fooService

    It is possible to provide multiple named tasks for a single node at once:

        ask < some lift > | task fooService barService

    The packaged data which is sent to the queue will contain the following data:
    - "node": The packed version of the Node. This is None there are no prior
    nodes in the Storm pipeline.
    - "tid": A task identifier. This is a randomly generated guid.  All events
    created from a single instance of this will have the same task identifier.
    - "tick": The system time when the task was fired.
    - "user": The user that fired the task. It may be None if authentication
    is not enabled on the Cortex.
    - "kwargs": A dictionary of additional keyword arguments provided by the
    user at runtime. These are left as strings for a downstream consumer to
    use.

    This command will not function if the Cortex is not configured for a task
    queuing endpoint.  The Cortex is only responsible for shipping the data to
    the queue. It is not responsible for managing any downstream consumers of
    that queue.
    '''

    name = 'task'

    def getArgParser(self):
        pars = Cmd.getArgParser(self)
        pars.add_argument('name', nargs='*',
                          help='Name of the task to fire.')
        pars.add_argument('-k', '--kwarg', action='append', default=[], nargs=2,
                          help='Additional keyword & value string arguments to include in the task message.')
        return pars

    def runStormCmd(self, snap, genr):
        # Is tasking even enabled on this Cortex?
        if snap.core.tqueue is None:
            raise s_exc.NoSuchConf(mesg='Cortex is not configured for tasking.')

        tid = s_common.guid()
        user = snap.user
        yielded = False

        # Get a unique list of names.
        names = list(set(self.opts.name))
        kwargs = {k: v for k, v in self.opts.kwarg}

        mesg = {
            'tid': tid,
            'user': user,
            'kwargs': kwargs,
            'tick': s_common.now(),
        }

        for node in genr:
            yielded = True
            # Replace the node key
            mesg['node'] = node.pack()
            for name in names:
                snap.core.tqueue.put((name, mesg))

            # Pass the node up to the next generator.
            yield node

        # Allow a empty task to be fired
        if not yielded:
            mesg['node'] = None
            for name in names:
                snap.core.tqueue.put((name, mesg))

        # The "what we did"
        for name in names:
            snap.printf(f'Fired task [{tid}][{name}]')
