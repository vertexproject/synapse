import shlex
import logging
import argparse

import synapse.exc as s_exc
import synapse.common as s_common
import synapse.lib.persist as s_persist

logger = logging.getLogger(__name__)

class Parser(argparse.ArgumentParser):

    def __init__(self, prog=None, descr=None):

        self.printf = None
        self.exited = False

        argparse.ArgumentParser.__init__(self,
            prog=prog,
            description=descr,
            formatter_class=argparse.RawDescriptionHelpFormatter)

    def exit(self, *args, **kwargs):
        # yea....  newp.
        self.exited = True

    def _print_message(self, text, fd=None):

        if self.printf is None:
            return

        for line in text.split('\n'):
            self.printf(line)

class Cmd:
    '''
    A one line description of the command.

    Command usage details and long form description.

    Example:

        cmd --help
    '''
    name = 'cmd'

    def __init__(self, text):
        self.opts = None
        self.text = text
        self.argv = self.getCmdArgv()
        self.pars = self.getArgParser()

    @classmethod
    def getCmdBrief(cls):
        return cls.__doc__.strip().split('\n')[0]

    def getCmdArgv(self):
        return shlex.split(self.text)

    def getArgParser(self):
        return Parser(prog=self.name, descr=self.__class__.__doc__)

    def reqValidOpts(self, snap):
        self.pars.printf = snap.printf
        self.opts = self.pars.parse_args(self.argv)
        return self.pars.exited

    def runStormCmd(self, snap, genr):
        yield from genr

class HelpCmd(Cmd):
    '''
    List available commands and a brief description for each.
    '''
    name = 'help'

    def getArgParser(self):
        pars = Cmd.getArgParser(self)
        pars.add_argument('command', nargs='?', help='Show the help output for a given command.')
        return pars

    def runStormCmd(self, snap, genr):

        yield from genr

        if not self.opts.command:
            for name, ctor in sorted(snap.core.getStormCmds()):
                snap.printf('%.20s: %s' % (name, ctor.getCmdBrief()))

        snap.printf('')
        snap.printf('For detailed help on any command, use <cmd> --help')

class LimitCmd(Cmd):
    '''
    Limit the number of nodes generated by the query in the given position.

    Example:

        inet:ipv4 | limit 10
    '''

    name = 'limit'

    def getArgParser(self):
        pars = Cmd.getArgParser(self)
        pars.add_argument('count', type=int, help='The maximum number of nodes to yield.')
        return pars

    def runStormCmd(self, snap, genr):

        for count, item in enumerate(genr):

            if count >= self.opts.count:
                snap.printf(f'limit reached: {self.opts.count}')
                break

            yield item

class DelNodeCmd(Cmd):
    '''
    Delete nodes produced by the previous query logic.

    (no nodes are returned)

    Example

        inet:fqdn=vertex.link | delnode
    '''
    name = 'delnode'

    def getArgParser(self):
        pars = Cmd.getArgParser(self)
        forcehelp = 'Force delete even if it causes broken references (requires admin).'
        pars.add_argument('--force', default=False, action='store_true', help=forcehelp)
        return pars

    def runStormCmd(self, snap, genr):

        # a bit odd, but we need to be detected as a generator
        yield from ()

        if self.opts.force:
            if snap.user is not None and not snap.user.admin:
                mesg = '--force requires admin privs.'
                return self._onAuthDeny(mesg)

        for node in genr:
            node.delete(force=self.opts.force)

class SudoCmd(Cmd):
    '''
    Use admin privileges to bypass standard query permissions.

    Example:

        sudo | [ inet:fqdn=vertex.link ]
    '''
    name = 'sudo'

    def runStormCmd(self, snap, genr):
        snap.elevated = True
        yield from genr

class QueueCmd(Cmd):
    '''
    Send nodes in the query to a named persistent queue.

    This can also be used to get a list of named endpoints and their
    descriptions.  This does return all of the nodes lifted in the
    current query.

    Example:

        # Get a list of named queues and their descriptions
        queue --list
        # Lift some nodes and send the to the queue named qt1
        inet:fqdn=vertex.link | queue qt1
    '''
    name = 'queue'

    def getArgParser(self):
        pars = Cmd.getArgParser(self)

        pars.add_argument('name', nargs='?', type=str, default=None,
                          help='Name of the queue to place nodes into.')
        pars.add_argument('-l', '--list', default=False, action='store_true',
                         help='List queues registered with the Cortex. No nodes will be queued if this option is '
                              'used.')
        pars.add_argument('-s', '--size', default=1000, type=int,
                          help='Number of nodes to consume at a time.')
        return pars

    def runStormCmd(self, snap, genr):
        if self.opts.list:
            descs = snap.core.getQueueDescs()
            if descs:
                snap.printf('The following queues are configured for the current Cortex.')
                for k, v in descs:
                    desc = v.get('desc', 'No description available.')
                    qtyp = v.get('type')
                    # XXX justify the fields here?
                    snap.printf(f'[{k}] - [{qtyp}] - {desc}')
            else:
                snap.printf('No queues are configured for the current Cortex.')
            yield from genr
            return

        name = self.opts.name
        conf = snap.core.queueConfs.get(name)
        if not conf:
            raise s_exc.NoSuchConf(mesg='Cortex is not configured for queuing to the specified endpoint.',
                                   name=name)
        cnt = 0
        for nodes in s_common.chunks(genr, size=self.opts.size):
            pnodes = [node.pack() for node in nodes]
            plen = len(pnodes)
            logger.debug('Queueing %s nodes to [%s]', plen, name)
            try:
                s_persist.queue(conf, pnodes)
            except Exception as e:
                logger.exception('Failed to queue %s nodes to [%s].', plen, name)
            else:
                cnt += plen
            finally:
                for node in nodes:
                    yield node

        # The "what we did"
        snap.printf(f'Queued [{cnt}] nodes to [{name}]')
