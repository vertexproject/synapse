// Grammar for the Storm Query Language (and miscellaneous bits)

%import common.ESCAPED_STRING

// Lark Grammar Notes:
// Lark uses standard EBNF notation with a few extra bells and whistles:
// * Rules and terminals that start with an underscore are not presented in the final parse tree.  The underscored
//   terminals are skipped entirely, and the underscored rule nodes are replaced by their children.
// * Rules ending with a .<num> are higher priority than other rules.
// * Rules starting with a ? have their parse tree node replaced by their children if they have exactly 1 child.

// Style Note:
// All string constants with length > 1 should have an explicit terminal name.  Lark already has a
// name defined for all 1-character strings.  Lark makes __ANON tokens for unnamed terminals.  We don't want those
// because it makes storm syntax errors harder to decipher.

// Entry point for an unadorned storm query
query: [(_WS | _CCOMMENT | _CPPCOMMENT)? "|"] (_WS | _CCOMMENT | _CPPCOMMENT)? _querystart? (_WS | _CCOMMENT | _CPPCOMMENT)?
lookup: _WS? looklist _WS? [ "|" query ]

_querystart: _querystart ((_WS | _CCOMMENT | _CPPCOMMENT)? "|" (_WS | _CCOMMENT | _CPPCOMMENT)? | (_WS | _CCOMMENT | _CPPCOMMENT)) (stormcmd | _oper | _editblock)
    | stormcmd | _oper | _editblock

// Edit block: zero or more edit operations inside a single set of square brackets
_editblock: "[" _editopers "]"
_editopers: (_WS | _CCOMMENT | _CPPCOMMENT)? _editoper ((_WS | _CCOMMENT | _CPPCOMMENT) _editoper)* (_WS | _CCOMMENT | _CPPCOMMENT)?

// A single edit operation
_editoper: editnodeadd
            | editpropset | editunivset | edittagpropset | edittagadd
            | editpropdel | editunivdel | edittagpropdel | edittagdel
            | editparens | edgeaddn1 | edgedeln1 | edgeaddn2 | edgedeln2

// Parenthesis in an edit block don't have incoming nodes
editparens: "(" _WS? editnodeadd [ _WS _editopers ] _WS? ")"
edittagadd: "+" [SETTAGOPER] tagname [_WS? "=" _WS? _valu]
editunivdel: "-" univprop
edittagdel: "-" tagname
editpropset: relprop _WS? SETOPER _WS? _valu
editpropdel: "-" relprop
editunivset: univprop _WS? SETOPER _WS? _valu
editnodeadd: formname _WS? SETOPER _WS? _valu
edittagpropset: "+" tagprop _WS? SETOPER _WS? _valu
edittagpropdel: "-" tagprop
SETOPER: "=" | "+=" | "-=" | _TRYSET
_TRYSET: "?=" | "?+=" | "?-="
SETTAGOPER: "?"

// The set of non-edit non-commands in storm
_oper: stormfunc | initblock | finiblock | trycatch | subquery | _formpivot | formjoin | formpivotin
     | formjoinin | lifttagtag | opervarlist | setitem | setvar | vareval | filtoper | liftbytag
     | operrelprop | forloop | whileloop | switchcase | BREAK | CONTINUE | return | emit | stop
     | _liftprop | ifstmt | yieldvalu | n1walk | n2walk | n1walknpivo | n2walknpivo | rawpivot

BREAK: "break"
CONTINUE: "continue"

catchblock: "catch" (_WS | _CCOMMENT | _CPPCOMMENT) _valu (_WS | _CCOMMENT | _CPPCOMMENT)? "as" (_WS | _CCOMMENT | _CPPCOMMENT)? VARTOKN (_WS | _CCOMMENT | _CPPCOMMENT)? "{" query "}"
trycatch: "try" (_WS | _CCOMMENT | _CPPCOMMENT)? "{" query "}" (_WS | _CCOMMENT | _CPPCOMMENT)? catchblock ((_WS | _CCOMMENT | _CPPCOMMENT)? catchblock)?

_STOP: "stop"
stop: _STOP
_RETURN: "return"
return: _RETURN _WS? "("[ _WS? _valu ] _WS?")"
_EMIT: "emit"
emit: _EMIT _WS _valu

// A bare variable reference, useful for a function call
vareval: _varvalu

// A variable assignment
setvar: "$" VARTOKN _WS? "=" _WS? _valu
setitem: _varvalu "." (VARTOKN | "$" varvalue) _WS? "=" _WS? _valu

forloop: "for" _WS ("$" VARTOKN | varlist) _WS? "in" _WS? _valu _WS? baresubquery
whileloop: "while" _WS _valu _WS? baresubquery
subquery: [YIELD _WS?] baresubquery
argvquery: "{" query "}"
baresubquery: "{" query "}"
YIELD: "yield"
switchcase: "switch" _WS _varvalu _WS? "{" ((_WS | _CCOMMENT | _CPPCOMMENT)? (DEFAULTCASE | DOUBLEQUOTEDSTRING | SINGLEQUOTEDSTRING | CASEBARE) (_WS | _CCOMMENT | _CPPCOMMENT)? ":" (_WS | _CCOMMENT | _CPPCOMMENT)? baresubquery)* (_WS | _CCOMMENT | _CPPCOMMENT)? "}"
DEFAULTCASE: "*"
CASEBARE: /(?!\*)([^:\s"']+)/

yieldvalu: YIELD _WS _argvalu

initblock: "init" (_WS | _CCOMMENT | _CPPCOMMENT)? "{" query "}"
finiblock: "fini" (_WS | _CCOMMENT | _CPPCOMMENT)? "{" query "}"

ifstmt: "if" ifclause ((_WS | _CCOMMENT | _CPPCOMMENT)? "elif" ifclause)* [(_WS | _CCOMMENT | _CPPCOMMENT)? "else" (_WS | _CCOMMENT | _CPPCOMMENT)? baresubquery]
// The stuff inside an if or elif
ifclause: _WS _valu (_WS | _CCOMMENT | _CPPCOMMENT)? baresubquery

// A bare variable list
varlist: "(" [_WS? "$" VARTOKN (_WS? "," _WS? "$" VARTOKN)*] _WS? ["," _WS?] ")"

// A variable list assignment
opervarlist: varlist _WS? "=" _WS? _valu

// Pivots
_formpivot: formpivot_pivottotags | formpivot_jointags | formpivot_pivotout | formpivot_
formpivot_pivottotags: _RIGHTPIVOT _WS? (ALLTAGS | _tagmatch)
formpivot_jointags: _RIGHTJOIN _WS? (ALLTAGS | _tagmatch)
// The special symbol that indicates to pivot to syn:tag nodes
ALLTAGS: "#"

formpivot_pivotout:    _RIGHTPIVOT _WS? "*"
formpivot_:            _RIGHTPIVOT _WS? ABSPROP

formjoin: _RIGHTJOIN _WS? "*"     -> formjoin_pivotout
        | _RIGHTJOIN _WS? ABSPROP -> formjoin_formpivot

formpivotin: _LEFTPIVOT _WS? "*" -> formpivotin_
           | _LEFTPIVOT _WS? ABSPROP -> formpivotin_pivotinfrom

formjoinin: _LEFTJOIN _WS? "*" -> formjoinin_pivotin
          | _LEFTJOIN _WS? ABSPROP -> formjoinin_pivotinfrom

operrelprop: relprop _WS? _RIGHTPIVOT _WS? ("*" | ABSPROP) -> operrelprop_pivot
           | relprop _WS? _RIGHTJOIN _WS? ("*" | ABSPROP) -> operrelprop_join

rawpivot: _RIGHTPIVOT _WS? "{" query "}"

_RIGHTJOIN:  "-+>"
_LEFTJOIN:   "<+-"
_RIGHTPIVOT: "->"
_LEFTPIVOT:  "<-"

_liftprop: liftformtag | liftpropby | liftprop | liftbyarray
            | liftbytagprop | liftbyformtagprop

WILDCARD: "*"

// A wild card, full prop, list, or $varvalu
_wildprops: WILDCARD | PROPS | valulist | _varvalu

n1walk: _EDGEN1INIT _valu _EDGEN1FINI _WS? _wildprops [ (_WS | _CCOMMENT | _CPPCOMMENT)? _cmpr (_WS | _CCOMMENT | _CPPCOMMENT)? _valu ]
n2walk: _EDGEN2INIT _valu _EDGEN2FINI _WS? _wildprops [ (_WS | _CCOMMENT | _CPPCOMMENT)? _cmpr (_WS | _CCOMMENT | _CPPCOMMENT)? _valu ]

_WALKNPIVON1: "-->"
_WALKNPIVON2: "<--"

n1walknpivo: _WALKNPIVON1 _WS? "*"
n2walknpivo: _WALKNPIVON2 _WS? "*"

_EDGEN1INIT: "-("
_EDGEADDN1INIT: "+("
_EDGEN1FINI: ")>"

_EDGEN2INIT: "<("
_EDGEADDN2FINI: ")+"
_EDGEN2FINI: ")-"

edgeaddn1: _EDGEADDN1INIT _valu _EDGEN1FINI _WS? baresubquery
edgedeln1: _EDGEN1INIT _valu _EDGEN1FINI _WS? baresubquery
edgeaddn2: _EDGEN2INIT _valu _EDGEADDN2FINI _WS? baresubquery
edgedeln2: _EDGEN2INIT _valu _EDGEN2FINI _WS? baresubquery

liftformtag: PROPNAME tagname [_WS? _cmpr _valu]
_DEREF:  "*"
liftpropby: (PROPNAME | _DEREF _varvalu) _WS? _cmpr _WS? _valu
liftprop: (PROPNAME | _DEREF _varvalu)
liftbyarray: (PROPNAME | _DEREF _varvalu) _WS? "*[" _WS? _safe_cmpr _WS? _valu _WS? "]"
lifttagtag: "#" tagname [_WS? _cmpr _valu]
liftbytag: tagname [_WS? _cmpr _valu]
liftbytagprop: tagprop [_WS? _cmpr _valu]
liftbyformtagprop: formtagprop [_WS? _cmpr _valu]
tagname: "#" _WS? (_varvalu | TAG)
tagprop: "#" TAG ":" BASEPROP
formtagprop: PROPNAME "#" TAG ":" BASEPROP

_funcarg: (VARTOKN | kwarg)
funcargs: "(" _WS? (_funcarg (_WS? "," _WS? _funcarg)* _WS? )? ")"
stormfunc: "function" _WS VARTOKN _WS? funcargs _WS? "{" query "}"

stormcmd: CMDNAME [ _WS stormcmdargs ]
stormcmdargs: _cmdargv (("=" | _WS) _cmdargv)*
CMDOPT: /-[a-zA-Z0-9_-]+/
_cmdargv: argvquery | CMDOPT | _toknvalu

// an argv parser for cmdr commands which may contain embedded queries
cmdrargs: _WS? _cmdrargv (("=" | _WS) _cmdrargv)*
_cmdrargv: baresubquery | DOUBLEQUOTEDSTRING | SINGLEQUOTEDSTRING | CMDRTOKN

// A tag with either a variable reference or a tag name potentially with asterisks
_tagmatch: "#" (_varvalu | TAGMATCH)
// A tag name with asterisks or $var as segment after the first segment
TAGMATCH:  _TAGSEGSTARNOVAR ( "." (_TAGSEGSTARNOVAR | "$" VARTOKN))*
_TAGSEGSTARNOVAR: /[\w*]+/

// A regular tag potentially with $var as any number of segments after the first
TAG: _TAGSEGNOVAR ("." (_TAGSEGNOVAR | "$" VARTOKN))*
_TAGSEGNOVAR: /\w+/

// A comparison operator
_cmpr: _by_cmpr | CMPR
_by_cmpr: "*" BYNAME
BYNAME: /[^=\s]+=/
CMPR: "=" | "<" | "<=" | ">" | ">=" | "!=" | "@=" | "^=" | "~="

_safe_cmpr: BYNAME | CMPR

_rootvalu: _varvalu | relpropvalu | univpropvalu | tagvalu | tagpropvalu | TRIPLEQUOTEDSTRING
    | DOUBLEQUOTEDSTRING | SINGLEQUOTEDSTRING | reqdollarexpr

// Common subset + stuff allowable in command arguments
_argvalu: _rootvalu | valulist | embedquery

// Used for most instances of values
_basevalu: _argvalu | baresubquery

_valu: _basevalu | NONQUOTEWORD

evalvalu: _valu
exprdict: "{" _WS? (_exprvalu _WS? ":" _WS? _exprvalu _WS? ("," _WS? _exprvalu _WS? ":" _WS? _exprvalu _WS?)* ("," _WS?)? )? "}"
exprlist: "[" _WS? (_exprvalu _WS? ("," _WS? _exprvalu _WS?)* ("," _WS?)? )? "]"

// Just like _valu, but doesn't allow valu lists or unquoted strings or queries
_exprvalu: NUMBER | HEXNUMBER | BOOL | exprlist | exprdict | _rootvalu

// command arguments
_toknvalu: _argvalu | WORDTOKN

_listvalu: _basevalu | LISTTOKN

_lookvalu: DOUBLEQUOTEDSTRING | SINGLEQUOTEDSTRING | WHITETOKN
looklist: (_lookvalu _WS?)*

valulist: "(" [_WS? _listvalu _WS? ((",")|("," _WS? _listvalu)+ [_WS? ","])] _WS? ")"
tagvalu: tagname
tagpropvalu: tagprop

relpropvalu: ":" BASEPROP | ":" _varvalu
univpropvalu: univprop
embedquery: _EMBEDQUERYSTART query "}"
_EMBEDQUERYSTART: "${"

// An unquoted storm string constant.  Must start with a word char, ?, /, \, +, *, or - and not contain certain punctuation
NONQUOTEWORD: /(?!\/\/)[\w\-\+\?\*\/\\][^\s\),=\]}\|]*/

// An unquoted string within a storm command argument list
// TODO: revisit this doesn't make sense
WORDTOKN: /(?!\/[\/\*])[\w\+\-\?\*\/\\][^\s\=\|\}\)]*/

// An unquoted string within a list syntax
LISTTOKN: /[\w\+\-\?\*\/\\]([^=,)]*[^\s,)])*/

// A white-space *only* delimited string immediate for use in legacy cmdr parser
CMDRTOKN: /[^="'\s\{}][^\s\{}]*/

WHITETOKN: /[^\s|]+/

// A value consisting of a name then 0 or more derefs and function calls
_varvalu: "$" _varvaluatom

_varvaluatom: varvalue | varderef | funccall
varvalue: VARTOKN
VARTOKN: /\w+/

// Similar fashion to variables in tag matching
varderef: _varvaluatom "." DEREFMATCHNOSEP
DEREFMATCHNOSEP: (VARTOKN | "$" VARTOKN)

funccall: _varvaluatom _callargs
_callargs: "(" [(_WS | _CCOMMENT | _CPPCOMMENT)? (kwarg | _valu) ((_WS | _CCOMMENT | _CPPCOMMENT)? "," (_WS | _CCOMMENT | _CPPCOMMENT)? (kwarg | _valu))*] (_WS | _CCOMMENT | _CPPCOMMENT)? ["," (_WS | _CCOMMENT | _CPPCOMMENT)?] ")"
kwarg: VARTOKN (_WS | _CCOMMENT | _CPPCOMMENT)? "=" (_WS | _CCOMMENT | _CPPCOMMENT)? _valu

filtoper: FILTPREFIX _cond
FILTPREFIX: "+" | "-"

// Condition used for filters
// TODO:  unify cond and dollarexpr
_cond: notcond | "(" _WS? _condexpr _WS? ")"
    | hasrelpropcond | relpropcond
    | abspropcond | hasabspropcond
    | tagpropcond | hastagpropcond
    | tagcond | tagvalucond
    | condsubq | arraycond
    | _varvalu | reqdollarexpr

notcond: "not" _WS _cond

hasrelpropcond: relpropvalue
relpropcond: relpropvalue _WS? _cmpr _WS? _valu
relpropvalue:   relprop | univprop

abspropcond:  ABSPROPNOUNIV _WS? _cmpr _WS? _valu
hasabspropcond: ABSPROPNOUNIV

tagpropcond:  tagprop _WS? _cmpr _WS? _valu
hastagpropcond: tagprop

tagvalucond:  _tagmatch _WS? _cmpr _WS? _valu
tagcond: _tagmatch

condsubq: "{" query "}" [(_WS | _CCOMMENT | _CPPCOMMENT)? _cmpr (_WS | _CCOMMENT | _CPPCOMMENT)? _valu]
arraycond: relprop _ARRAYCONDSTART _WS? _safe_cmpr _WS? _valu _WS? "]"
_ARRAYCONDSTART: "*["

// Filter boolean conditions
_condexpr: _cond | orexpr | andexpr
orexpr: _condexpr _WS "or" _WS _cond
andexpr: _condexpr _WS "and" _WS _cond

TRIPLEQUOTEDSTRING: /'''.*?'''/s
DOUBLEQUOTEDSTRING: ESCAPED_STRING
SINGLEQUOTEDSTRING: /'[^']*'/

_WS: /[\s]/+

// C comment: /* */
// From https://stackoverflow.com/a/36328890/6518334
_CCOMMENT: /\/\*+[^*]*\*+([^\/*][^*]*\*+)*\//

// C++ comment: //
_CPPCOMMENT: /\/\/[^\n]*/

// Must be kept consistent with same regexes in synapse/lib/grammar.py
// A full property.  Must contain at least 1 colon
PROPS: /[a-z_][a-z0-9_]*(:[a-z0-9_]+)+([:.][a-z0-9_]+)*/
// A universal property
UNIVNAME: /\.[a-z_][a-z0-9_]*([:.][a-z0-9_]+)*/
univprop:  UNIVNAME | "." _varvalu
// A full property or a universal property
PROPNAME: PROPS | UNIVNAME
ABSPROP: PROPNAME
ABSPROPNOUNIV: PROPS
formname: PROPS | _DEREF _varvalu
// A relative property
relprop: ":" BASEPROP | ":" _varvalu

// Similar to PROPS, but starts with a colon and allows :: as separator
RELNAME: /\:\.?[a-z_][a-z0-9_]*(?:(\:\:|\:|\.)[a-z_][a-z0-9_]+)*/

// Similar to PROPS but does not require a colon
BASEPROP: /[a-z_][a-z0-9_]*(?:(\:\:|\:|\.)[a-z_][a-z0-9_]*)*/

// The name of a storm command
CMDNAME: /\b(?!(init|fini|function|return|emit|stop|yield|break|continue|for|while|switch|else|elif|if|not|or|and|try|catch)\b)[a-z][a-z0-9.]+(?=($|[\s\|\}]))\b/

// The entry point for a $(...) expression.  The initial dollar sign is now optional
dollarexpr: "$"? _exprcommon
// A dollar expression with a required dollar
reqdollarexpr: "$" _exprcommon
_exprcommon: "(" (_WS | _CCOMMENT | _CPPCOMMENT)? expror (_WS | _CCOMMENT | _CPPCOMMENT)? ")"
EXPRCMPR: /<=|>=|<|>|=|!=|~=|\^=/
EXPRPLUS: "+"
EXPRMINUS: "-"
EXPRTIMES: "*"
EXPRDIVIDE: "/"
NUMBER: /-?\d+(\.\d*)?/
HEXNUMBER: /-?0x[0-9a-fA-F]+/
BOOL: /true|false/
NOT: "not"
OR: "or"
AND: "and"

// $ expression rules in increasing order of precedence (modeled on Python's order)
?expror: exprand | expror (_WS | _CCOMMENT | _CPPCOMMENT) OR (_WS | _CCOMMENT | _CPPCOMMENT) exprand
?exprand: exprnot | exprand (_WS | _CCOMMENT | _CPPCOMMENT) AND (_WS | _CCOMMENT | _CPPCOMMENT) exprnot
?exprnot: exprcmp | NOT (_WS | _CCOMMENT | _CPPCOMMENT) exprcmp
?exprcmp: exprsum | exprcmp (_WS | _CCOMMENT | _CPPCOMMENT)? EXPRCMPR (_WS | _CCOMMENT | _CPPCOMMENT)? exprsum
?exprsum: exprproduct | exprsum (_WS | _CCOMMENT | _CPPCOMMENT)? (EXPRPLUS | EXPRMINUS) (_WS | _CCOMMENT | _CPPCOMMENT)? exprproduct
?exprproduct: _expratom | exprproduct (_WS | _CCOMMENT | _CPPCOMMENT)? (EXPRTIMES | EXPRDIVIDE) (_WS | _CCOMMENT | _CPPCOMMENT)? _expratom
_expratom: _exprvalu
