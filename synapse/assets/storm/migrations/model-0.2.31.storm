$layers = $lib.spooled.set()
$layers.adds($layridens)

$views = $lib.view.list(deporder=(true))
$rviews = $lib.view.list(deporder=(true))
$rviews.reverse()

$refinfoCache = ({})

function getRefInfo(formname) {
    $cached = $refinfoCache.$formname
    if $cached { return($cached) }

    $refinfo = ([])

    syn:prop:type*in=($formname, array, ndef)
    // Don't include the form we're querying
    -:form = $formname

    $prop = $lib.model.prop($node.repr())
    $proptype = $prop.type.name

    // Don't include array types that don't have a base type of $formname or ndef
    -$($proptype = 'array' and not ([$formname, 'ndef']).has($prop.type.opts.type))

    $isarray = $lib.false

    if ($proptype = 'array') {
        $isarray = $lib.true
        $proptype = $prop.type.opts.type
    }

    $refinfo.append((:form, $prop.name, $proptype, $isarray))

    fini {
        $refinfoCache.$formname = $refinfo
        return($refinfo)
    }
}

function removeNode(n, viewiden, layriden, refiden=$lib.null) {

    $nodeq = $lib.queue.gen("model_0_2_31:nodes")
    $refsq = $lib.queue.gen("model_0_2_31:nodes:refs")
    $edgeq = $lib.queue.gen("model_0_2_31:nodes:edges")
    $editq = $lib.queue.gen("model_0_2_31:nodes:edits")

    $iden = $n.iden()
    $repr = $n.repr()
    $form = $n.form()
    $ndef = $n.ndef()

    $lib.log.debug(`Saving invalid {$form} node info: {$repr}`)

    $refinfos = $getRefInfo($form)

    $references = ([])

    // This loop recursively removes all the references to the node about to be deleted
    for $view in $views {
        if (not $layers.has($view.layers.0.iden)) { continue }

        view.exec $view.iden {

            // Get references and store them in queue
            for $refinfo in $refinfos {

                ($formname, $propname, $proptype, $isarray) = $refinfo
                if ($proptype = "ndef") {
                    $oldvalu = $ndef
                } else {
                    $oldvalu = $repr
                }

                for $ref in $lib.model.migration.liftByPropValuNoNorm($formname, $propname, $oldvalu) {
                    yield $ref

                    if $isarray {

                        // We can't just [ :$propname-=$oldvalu ] because the norm() function gets called on the array type
                        // deep down in the AST. So, instead, we have to operate on the whole array.

                        $list = $lib.copy(:$propname)
                        $list.rem($oldvalu, all=$lib.true)

                        if $list {
                            $lib.model.migration.setNodePropValuNoNorm($node, $propname, $list)
                        } else {
                            [ -:$propname ]
                        }

                    } else {
                        try {
                            [ -:$propname ]
                        } catch ReadOnlyProp as exc {
                            // The property is readonly so we can only delete it
                            $lib.log.warning(`{$formname}:{$propname} is readonly, cannot modify. Storing node: {$node.repr()}`)
                            $removeNode($node, $view.iden, $view.layers.0.iden, refiden=$iden)
                            | delnode |
                            continue
                        }
                    }

                    $ref = ({
                        "iden": $node.iden(),
                        "refinfo": $refinfo,
                    })

                    $references.append($ref)

                    // Flush to the queue if the list grows too large
                    if ($references.size() > 1000) { // pragma: no cover start
                        $item = ({
                            "iden": $iden,
                            "view": $view.iden,
                            "refs": $references,
                        })

                        $refsq.put($item)
                        $references = ([])
                    } // pragma: no cover stop
                }
            }
        }
    }

    if $references {
        $item = ({
            "iden": $iden,
            "view": $view.iden,
            "refs": $references,
        })

        $refsq.put($item)
        $references = ([])
    }

    $edges = ([])
    $edits = ([])
    $sources = $lib.spooled.set()

    // This loop stores all the edits and edges from every layer
    for $rview in $rviews {
        if (not $layers.has($rview.layers.0.iden)) { continue }

        view.exec $rview.iden {
            $layer = $rview.layers.0

            $edit = ({})

            $data = ({})
            for ($name, $valu) in $layer.getNodeData($iden) {
                $data.$name = $valu
            }

            if $data {
                $edit.data = $data
            }

            $sode = $layer.getStorNode($iden)
            if $sode {
                if $sode.props { $edit.props = $sode.props }
                if $sode.tags { $edit.tags = $sode.tags }
                if $sode.tagprops { $edit.tagprops = $sode.tagprops }
            }

            if $edit {
                $edit.view = $rview.iden
                $edit.layer = $layer.iden
                $edits.append($edit)
            }

            // Flush to the queue if the list grows too large
            if ($edits.size() > 1000) { // pragma: no cover start
                $item = ({
                    "iden": $iden,
                    "edits": $edits,
                })

                $editq.put($item)
                $edits = ([])
            } // pragma: no cover stop

            $edge = ({})

            // Get N1 edges and store them in the queue
            for $n1edge in $layer.getEdgesByN1($iden) {
                ($verb, $dst) = $n1edge
                $edge.verb = $verb
                $edge.node = $dst
                $edge.direction = "n1"
                $edge.layer = $layer.iden
                $edge.view = $rview.iden

                $edges.append($edge)

                // Flush to the queue if the list grows too large
                if ($edges.size() > 1000) { // pragma: no cover start
                    $item = ({
                        "iden": $iden,
                        "edges": $edges,
                    })

                    $edgeq.put($item)
                    $edges = ([])
                } // pragma: no cover stop
            }

            // Get N2 edges and store them in the queue
            for $n2edge in $layer.getEdgesByN2($iden) {
                ($verb, $src) = $n2edge
                $edge.verb = $verb
                $edge.node = $src
                $edge.direction = "n2"
                $edge.layer = $layer.iden
                $edge.view = $rview.iden
                $edges.append($edge)

                // Flush to the queue if the list grows too large
                if ($edges.size() > 1000) { // pragma: no cover start
                    $item = ({
                        "iden": $iden,
                        "edges": $edges,
                    })

                    $edgeq.put($item)
                    $edges = ([])
                } // pragma: no cover stop
            }

            yield $iden

            // Get sources and store them in the queue
            { <(seen)- meta:source
                $sources.add($node.repr())
            }

            // We've captured the edits from this layer, delete the node to remove them
            delnode --deledges --force
        }
    }

    if $edges {
        $item = ({
            "iden": $iden,
            "edges": $edges,
        })

        $edgeq.put($item)
        $edges = ([])
    }

    if $edits {
        $item = ({
            "iden": $iden,
            "edits": $edits,
        })

        $editq.put($item)
        $edits = ([])
    }

    $item = ({
        "iden": $iden,
        "form": $form,
        "valu": $repr,
        "view": $viewiden,
        "layer": $layriden,
        "refiden": $refiden,
        "sources": $sources.list(),
    })

    $nodeq.put($item)

    return()
}

function migrateCpeNode(oldcpe, newcpe) {

    $refinfos = $getRefInfo($oldcpe.form())

    // Iterate through the views and fix up all the references
    for $view in $views {
        if (not $layers.has($view.layers.0.iden)) { continue }

        view.exec $view.iden {

            // Fix references that point to old node to now point to new node
            for $refinfo in $refinfos {
                ($form, $prop, $proptype, $isarray) = $refinfo
                if ($proptype = "ndef") {
                    $oldvalu = $oldcpe.ndef()
                    $newvalu = $newcpe.ndef()
                } else {
                    $oldvalu = $oldcpe.repr()
                    $newvalu = $newcpe.repr()
                }

                for $n in $lib.model.migration.liftByPropValuNoNorm($form, $prop, $oldvalu) {
                    yield $n

                    if $isarray {

                        // We can't just [ :$prop-=$oldvalu :$prop+=$newvalu ] because the norm() function gets called
                        // on the array type deep down in the AST. So, instead, we have to operate on the whole array.

                        $list = $lib.copy(:$prop)
                        $list.rem($oldvalu, all=$lib.true)

                        if (not $list.has($newvalu)) {
                            $list.append($newvalu)
                        }

                        $lib.model.migration.setNodePropValuNoNorm($node, $prop, $list)

                    } else {
                        try {
                            [ -:$prop :$prop=$newvalu ]
                        } catch ReadOnlyProp as exc {
                            // The property is readonly so we can only delete it
                            $lib.log.warning(`{$form}:{$prop} is readonly, cannot modify. Storing node: {$node.repr()}`)
                            $removeNode($node, $view.iden, $view.layers.0.iden, refiden=$oldcpe.iden())
                            | delnode

                        }
                    }
                }
            }
        }
    }

    return()
}

// This is a separate function because I was getting weird bugs from scoping
// issues. Mainly, the $view variable being overwritten because this code was
// scoped to the whole script.
function main() {

    // Delete invalid floating :v2_2 props in all views
    for $rview in $rviews {
        if (not $layers.has($rview.layers.0.iden)) { continue }

        view.exec $rview.iden {

            for $sode in $rview.layers.0.getStorNodesByForm(it:sec:cpe) {
                ($buid, $info) = $sode

                // If the valu is present on the sode, this is a full node in this view, go around
                if ($info.valu or not $info.props.v2_2) { continue }

                ($ok, $norm) = $lib.trycast(it:sec:cpe:v2_2, $info.props.v2_2.0)
                if $ok { continue }

                // This is an invalid floating :v2_2 prop. Remove it.
                yield $buid
                [ -:v2_2 ]
            }
        }
    }

    for $view in $views {

        if (not $layers.has($view.layers.0.iden)) { continue }

        view.exec $view.iden {

            $layer = $lib.layer.get()

            for $oldcpe in $layer.liftByProp(it:sec:cpe) {
                $info = $lib.model.migration.s.itSecCpe_2_170_0_internal($oldcpe)
                $iden = $oldcpe.iden()

                if ($info.status = "success") {
                    // No primary property changes, nothing to do. Node has been fully migrated.
                    if (not $info.valu) {
                        continue
                    }

                    /*
                     * At this point, we have a node that can be fixed but
                     * needs to be migrated to a new node because the primary
                     * property needs to be changed. We'll create a new
                     * (correct) node, and copy everything from the old node.
                     * Then we complete the migration by iterating through
                     * all the views to fix the references.
                     */

                    $lib.log.debug(`Migrating invalid it:sec:cpe node: {$oldcpe.repr()} -> {$info.valu}`)

                    [ it:sec:cpe=$info.valu
                        .seen ?= $oldcpe.props.".seen"
                    ]

                    // migrate the edges, tags, node data, and extended props.
                    $lib.model.migration.copyEdges($oldcpe, $node)
                    $lib.model.migration.copyTags($oldcpe, $node)
                    $lib.model.migration.copyData($oldcpe, $node)
                    $lib.model.migration.copyExtProps($oldcpe, $node)

                    $migrateCpeNode($oldcpe, $node)

                    | spin |

                    // Iterate through the views in reverse deporder looking for floating node edits
                    for $rview in $rviews {
                        if (not $layers.has($rview.layers.0.iden)) { continue }

                        // Only process views that are higher than the original view
                        if ($rview.iden = $view.iden) { break }

                        view.exec $rview.iden {

                            function getNewCpe() { it:sec:cpe=$info.valu return($node) }

                            $dst = $getNewCpe()
                            yield $iden

                            $lib.model.migration.copyNodeLayer($node, $dst)

                            delnode --deledges --force
                        }
                    }

                } else {

                    // Node could not be automatically migrated. Collect
                    // critical information to eventually reconstruct this node
                    // and store it in a queue.

                    $removeNode($oldcpe, $view.iden, $view.layers.0.iden)
                }

                yield $oldcpe |
                delnode --deledges --force
            }
        }
    }

    return()
}

// Pre-cache the it:sec:cpe references
$getRefInfo(it:sec:cpe)

$main()
