'''
Sync splices from an 0.1.x cortex to 0.2.x
'''
import os
import sys
import asyncio
import logging
import argparse

import synapse.common as s_common
import synapse.telepath as s_telepath

import synapse.lib.cell as s_cell
import synapse.lib.base as s_base
import synapse.lib.queue as s_queue
import synapse.lib.config as s_config
import synapse.lib.output as s_output

logger = logging.getLogger(__name__)

class SyncMigratorApi(s_cell.CellApi):
    '''
    A telepath/cell API for the Sync service.
    '''
    async def status(self):
        return await self.cell.status()

    async def startSyncFromFile(self):
        return await self.cell.startSyncFromFile()

    async def startSyncFromLast(self):
        return await self.cell.startSyncFromFile()

class SyncMigrator(s_cell.Cell):
    cellapi = SyncMigratorApi
    confdefs = {
        'src': {
            'type': 'string',
            'description': 'Telepath URL for the source 0.1.x cortex.',
        },
        'dest': {
            'type': 'string',
            'description': 'Telepath URL for the destination 0.2.x cortex.',
        },
        'offsfile': {
            'type': 'string',
            'description': 'File path for the YAML file containing layer offsets.'
        }
    }

    async def __anit__(self, dirn, conf=None):
        await s_cell.Cell.__anit__(self, dirn, conf=conf)

        self.src = self.conf.get('src')
        self.dest = self.conf.get('dest')
        self.offsfile = self.conf.get('offsfile')  # TODO

        self.poll_s = 60
        self.pull_fair_iter = 100
        self.push_fair_iter = 100
        self.batch_size = 10

        self.pull_offs = await self.hive.dict(('sync:pulloffs', ))
        self.push_offs = await self.hive.dict(('sync:pushoffs', ))
        self.errors = await self.hive.dict(('sync:errors', ))  # TODO

        self.model = None  # TODO

        self._pull_tasks = {}  # lyriden: task
        self._push_tasks = {}  # lyriden: task

        self.pull_last_start = {}  # TODO
        self.push_last_start = {}  # TODO

        self._queues = {}  # lyriden: queue of splices

    async def status(self):
        pass  # TODO

    async def startSyncFromFile(self):
        '''
        Start sync from layer offsets provided in offsfile generated by migration tool.
        '''
        pass  # TODO

    async def startSyncFromLast(self):
        '''
        Start sync from minimum last offset stored by push and pull.
        '''
        pass  # TODO

    async def _startLyrSync(self, lyriden, nextoffs):
        '''
        Starts up the sync process for a given layer and starting offset.
        Creates layer queue and fires layer push/pull tasks if they do not already exist.

        Args:
            lyriden (str): Layer iden
            nextoffs (int): The layer offset to start sync from
        '''
        await self._setLyrOffset('pull', lyriden, nextoffs)

        queue = self._queues.get(lyriden)
        if queue is None:
            queue = await s_queue.Window.anit(maxsize=None)
            self.onfini(queue.fini)
            self._queues[lyriden] = queue

        pulltask = self._pull_tasks.get(lyriden)
        if pulltask is None or pulltask.done():
            self._pull_tasks[lyriden] = self.schedCoro(self._srcPullLyrSplices(lyriden))

        pushtask = self._push_tasks.get(lyriden)
        if pushtask is None or pushtask.done():
            self._push_tasks[lyriden] = self.schedCoro(self._destPushLyrNodeedits(lyriden))

    async def _setLyrOffset(self, pushorpull, lyriden, offset):
        '''
        Stores the next offset to be read for a given layer.

        Args:
            pushorpull (str): "pull" or "push" to define context for stored offset
            lyriden (str): Layer iden
            offset (int): The offset to start sync from
        '''
        if pushorpull == 'pull':
            await self.pull_offs.set(lyriden, offset)
        elif pushorpull == 'push':
            await self.push_offs.set(lyriden, offset)

    async def _getLyrOffset(self, pushorpull, lyriden):
        '''
        Retrieve the next layer offset to be read.

        Args:
            pushorpull (str): "pull" or "push" to define context for stored offset
            lyriden (str): Layer iden

        Returns:
            (int or None): Next offset or None if layer offset does not exist
        '''
        if pushorpull == 'pull':
            return self.pull_offs.get(lyriden, default=None)
        elif pushorpull == 'push':
            return self.push_offs.get(lyriden, default=None)

    async def _setLyrErr(self, lyriden, offset, mesg):
        pass  # TODO

    async def _getLyrErr(self, lyriden, offset=None):
        pass  # TODO

    async def _loadDatamodel(self):
        pass  # TODO

    async def _srcPullLyrSplices(self, lyriden):
        '''
        Open a proxy to the source layer and initiates splice reader.
        Intended to be run as a fired task, and will poll for updates every poll_s.

        Args:
            lyriden (str): Layer iden
        '''
        poll_s = self.poll_s
        queue = self._queues.get(lyriden)
        async with await s_telepath.openurl(os.path.join(self.src, 'cortex', 'layer', lyriden)) as prx:
            while not self.isfini:
                startoffs = await self._getLyrOffset('pull', lyriden)

                logger.info(f'Pulling splices for layer {lyriden} starting from offset {startoffs}')
                self.pull_last_start[lyriden] = s_common.now()
                nextoffs = await self._srcIterLyrSplices(prx, startoffs, queue)

                await self._setLyrOffset('pull', lyriden, nextoffs)

                logger.info(f'All splices from {lyriden} have been read; offsets: {startoffs} -> {nextoffs}')
                await asyncio.sleep(poll_s)

    async def _srcIterLyrSplices(self, prx, startoffs, queue):
        '''
        Iterate over available splices for a given source layer proxy, and push into queue

        Args:
            prx (s_telepath.Proxy): Proxy to source layer
            startoffs (int): Offset to start iterating from
            queue (s_queue.Window): Layer queue for splices

        Returns:
            (int): Next offset to start from when all splices have been read
        '''
        curoffs = startoffs
        fair_iter = self.pull_fair_iter
        async for splice in prx.splices(startoffs, -1):
            await queue.put((curoffs, splice))

            curoffs += 1

            if curoffs % fair_iter == 0:
                await asyncio.sleep(0)

        return curoffs

    async def _trnSpliceToEdit(self, splice):
        '''
        Translate an individual splice to a nodeedit edit syntax.

        Args:
            splice (tuple): (<edit>, {<splice info>})

        Returns:
            (tuple): (<edit type>, <info>, ...)
        '''
        return splice  # TODO

    async def _trnNodeSplicesToNodeedit(self, ndef, splices):
        '''
        Translate a batch of splices for a given node into a nodeedit set

        TODO: Error handling

        Args:
            ndef (tuple): (<form>, <valu>)
            splices (list): [ (<edit>, {<splice info>}), ...]

        Returns:
            (tuple): (cond, nodeedit)
                cond: None or error dict
                nodeedit: (<buid>, <form>, [edits]) where edits is list of (<type>, <info>)
        '''
        buid = s_common.buid(ndef)
        form = ndef[0]

        edits = [await self._trnSpliceToEdit(splice) for splice in splices]

        return None, (buid, form, edits)

    async def _destPushLyrNodeedits(self, lyriden):
        '''
        Open a proxy to the given destination layer and initiate the queue reader.
        Intended to be run as a fired task.

        Args:
            lyriden (str): Layer iden
        '''
        queue = self._queues.get(lyriden)
        async with await s_telepath.openurl(os.path.join(self.dest, 'cortex', 'layer', lyriden)) as prx:
            logger.info(f'Starting {lyriden} splice queue reader')
            self.push_last_start[lyriden] = s_common.now()
            await self._destIterLyrNodeedits(prx, queue, lyriden)

    async def _destIterLyrNodeedits(self, prx, queue, lyriden):
        '''
        Batch available source splices in a queue as nodeedits and push to the destination layer proxy.

        Will run as long as queue is not fini'd.

        Args:
            prx (s_telepath.Proxy): Proxy to destination layer
            queue (s_queue.Window): Layer queue for splices
            lyriden (str): Layer iden
        '''
        fair_iter = self.push_fair_iter
        batch_size = self.batch_size

        ndef = None
        nodesplices = []
        nodeedits = []

        cnt = 0
        errs = 0
        async for offs, splice in queue:
            splice_ndef = splice[1]['ndef']

            # current splice is a new node so create prior node nodeedit
            # and optionally push to destination layer
            if ndef is not None and splice_ndef != ndef:
                err, ne = await self._trnNodeSplicesToNodeedit(ndef, nodesplices)
                if err is None:
                    nodeedits.append(ne)
                else:
                    errs += 1
                    pass  # TODO

                nodesplices = []

                if len(nodeedits) >= batch_size:
                    # await prx.foo(nodeddits)  # TODO
                    await self._setLyrOffset('push', lyriden, offs + 1)
                    nodeedits = []

            ndef = splice_ndef
            nodesplices.append(splice)

            cnt += 1
            if cnt % fair_iter == 0:
                logger.info(f'Yielding {lyriden} queue reader: read={cnt}, errs={errs}, size={len(queue.linklist)}')
                await asyncio.sleep(0)

        # finish last node splices
        if len(nodesplices) > 0:
            err, ne = await self._trnNodeSplicesToNodeedit(ndef, nodesplices)
            if err is None:
                nodeedits.append(ne)
            else:
                errs += 1
                pass  # TODO

        if len(nodeedits) > 0:
            # await prx.foo(nodeddits)  # TODO
            await self._setLyrOffset('push', lyriden, offs + 1)

def getParser():
    https = os.getenv('SYN_UNIV_HTTPS', '4443')
    telep = os.getenv('SYN_UNIV_TELEPATH', 'tcp://0.0.0.0:27492/')
    telen = os.getenv('SYN_UNIV_NAME', None)

    pars = argparse.ArgumentParser(prog='synapse.tools.sync_020')
    s_config.common_argparse(pars, https=https, telep=telep, telen=telen)

    return pars

async def cb(cell, opts, outp):
    await s_config.common_cb(cell, opts, outp)

async def main(argv, outp=s_output.stdout):
    pars = getParser()
    cell = await s_config.main(SyncMigrator, argv, pars=pars, cb=cb, outp=outp)
    return cell

if __name__ == '__main__':  # pragma: no cover
    asyncio.run(s_base.main(main(sys.argv[1:])))
